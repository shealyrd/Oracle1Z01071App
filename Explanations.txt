{"explanation":"Data manipulation language (DML) statements access and manipulate data in existing schema objects. Because SELECT is used to access data in a table or view, it is considered a DML command.","id":0},
{"explanation":"Data manipulation language (DML) statements access and manipulate data in existing schema objects. Because INSERT is used to add data to a table, it is considered a DML command.","id":1},
{"explanation":"Data manipulation language (DML) statements access and manipulate data in existing schema objects. Because UPDATE allows you to change existing data in a table, it is a DML statement.","id":2},
{"explanation":"Data manipulation language (DML) statements access and manipulate data in existing schema objects. Because DELETE removes data from a table, it is a DML statement.","id":3},
{"explanation":"Data manipulation language (DML) statements access and manipulate data in existing schema objects. Because MERGE conditionally deletes, inserts or modifies data in a table, it is considered a DML statement.","id":4},
{"explanation":"Data definition language (DDL) statements let you manipulate database objects or privileges.  Because CREATE instantiates a new database object, it is a DDL command.","id":5},
{"explanation":"Data definition language (DDL) statements let you manipulate database objects or privileges.  Because ALTER allows you to change the internal attributes of a database object, it is considered a DDL command.","id":6},
{"explanation":"Data definition language (DDL) statements let you manipulate database objects or privileges.  Because DROP removes an object from the database, it is a DDL command.","id":7},
{"explanation":"Data definition language (DDL) statements let you manipulate database objects or privileges. Because RENAME changes the name of a database object, it is a DDL command.","id":8},
{"explanation":"This one is tricky. Although TRUNCATE is used to remove data from a table, it does so by changing internal attributes of the table object, therefore it is a DDL command. Oracle explicitly classifies TRUNCATE as a DDL command.","id":9},
{"explanation":"Data definition language (DDL) statements let you manipulate database objects or privileges. Because GRANT is used to bestow privileges, it is a DDL command.","id":10}
{"explanation":"Data definition language (DDL) statements let you manipulate database objects or privileges. Because REVOKE is used to remove privileges, it is a DDL command.","id":11},
{"explanation":"Data definition language (DDL) statements let you manipulate database objects or privileges. Because FLASHBACK is used to revert a database object to a previous version of itself, it is a DDL statement.","id":12},
{"explanation":"Data definition language (DDL) statements let you manipulate database objects or privileges. Because PURGE is used to permanently remove an object from the database, it is a DDL command.","id":13},
{"explanation":"The scope of data definition language (DDL) statements includes adding comments to the data dictionary, so COMMENT is a DDL command.","id":14},
{"explanation":"Transaction control (TCL) statements manage changes made by DML statements. Because COMMIT is used to save the changes made by a set of DML statements, it is a TCL command.","id":15},
{"explanation":"Transaction control (TCL) statements manage changes made by DML statements. Because ROLLBACK is used to revert changes made by a set of DML commands, it is a TCL command.","id":16},
{"explanation":"CREATE is used to instantiate a new database object. ALTER is used to manipulate a database object. SELECT is used to access data in a table or view. GRANT is used to bestow a privilege. UPDATE is used to modify existing data in a table.","id":17},
{"explanation":"ALTER is used to manipulate a database object. CREATE is used to instantiate a new database object. SELECT is used to access data in a table or view. GRANT is used to bestow a privilege. UPDATE is used to modify existing data in a table.","id":18},
{"explanation":"DROP is used to remove an object from the database. ROLLBACK is used to revert changes made by a set of DML statements. DELETE is used to remove rows from a table. PURGE is used to permanently drop a database object. REVOKE is used to take a privileges away. ALTER is used to manipulate a database object.","id":19},
{"explanation":"CREATE is used to instantiate a new database object. ALTER is used to manipulate a database object. SELECT is used to access data in a table or view. GRANT is used to bestow a privilege. UPDATE is used to modify existing data in a table.","id":20},
{"explanation":"ALTER is used to manipulate a database object. CREATE is used to instantiate a new database object. SELECT is used to access data in a table or view. GRANT is used to bestow a privilege. UPDATE is used to modify existing data in a table.","id":21},
{"explanation":"DROP is used to remove an object from the database. ROLLBACK is used to revert changes made by a set of DML statements. DELETE is used to remove rows from a table. PURGE is used to permanently drop a database object. REVOKE is used to take a privileges away. ALTER is used to manipulate a database object.","id":22},
{"explanation":"RENAME is used to change the name of a database object. COMMENT is used to add an annotation to the data dictionary. ALTER is used to modify a database object. UPDATE is used to modify existing data in a table. CREATE is used to instantiate a new database object.","id":23},
{"explanation":"TRUNCATE is used to immediately remove all records from a table, partition or subpartition by changing the internal object attributes. DROP is used to remove an object from the database. ROLLBACK is used to revert changes made by a set of DML statements. DELETE is used to remove rows from a table. PURGE is used to permanently drop a database object.","id":24},
{"explanation":"GRANT is used to bestow a privilege. ALTER is used to modify a database object. CREATE is used to instantiate a new database object. REVOKE is used to take a privileges away. SELECT is used to access data in a table or view.","id":25},
{"explanation":"REVOKE is used to take a privileges away. TRUNCATE is used to immediately remove all records from a table, partition or subpartition by changing the internal object attributes. DROP is used to remove an object from the database. DELETE is used to remove rows from a table. REMOVE is not a real SQL command.","id":26},
{"explanation":"FLASHBACK is used to revert a database object to a previous version of itself. ROLLBACK is used to revert changes made by a set of DML statements. RESTORE is not a real SQL command. UPDATE is used to modify existing data in a table. REVERT is not a real SQL command.","id":27},
{"explanation":"PURGE is used to permanently drop a database object and remove it from the recycle bin. TRUNCATE is used to immediately remove all records from a table, partition or subpartition by changing the internal object attributes. COMMIT is used to save changes made by a set of DML statements. DROP is used to remove an object from the database. EMPTY is not a real SQL command.","id":28},
{"explanation":"COMMENT is used to add an annotation to the data dictionary. UPDATE is used to modify existing data in a table. ALTER is used to modify a database object. ANNOTATE is not a real SQL command. REFERENCE is not a real SQL command.","id":29},
{"explanation":"SELECT is used to access data in a table or view. SHOW is not a real SQL command. DATA is not a real SQL command. DISPLAY is not a real SQL command. INSERT is used to insert rows into a table.","id":30},
{"explanation":"INSERT is used to add new rows to a table. UPDATE is used to modify existing data in a table. ALERT is not a real SQL command. ROW is not a real SQL command. CREATE is used to instantiate a new database object. ","id":31},
{"explanation":"UPDATE is used to modify existing data in a table. INSERT is used to insert rows into a table. MODIFY is not a real SQL command. ALTER is used to modify a database object. RENAME is used to change the name of a database object.","id":32},
{"explanation":"DELETE is used to remove rows from a table. DROP is used to remove an object from the database. TRUNCATE is used to immediately remove all records from a table, partition or subpartition by changing the internal object attributes. PURGE is used to permanently drop a database object and remove it from the recycle bin. REMOVE is not a real SQL command.","id":33},
{"explanation":"MERGE selects rows from one or more source to conditionally insert, update or delete rows in a table. INSERT is used to insert rows into a table. UPDATE is used to modify existing data in a table. DELETE is used to remove rows from a table. ALTER is used to modify a database object.","id":34},
{"explanation":"COMMIT is used to save changes made by a set of DML statements. SAVE is not a real SQL command. ROLLBACK is used to revert changes made by a set of DML statements. SAVEPOINT is used to mark a specific instance in time or execution flow. EXECUTE IMMEDIATE is used to execute a string as if it were a SQL statement.","id":35},
{"explanation":"ROLLBACK is used to revert changes made by a set of DML statements. REVOKE is used to take a privileges away. RESET is not a real SQL command. DELETE is used to remove rows from a table. FLASHBACK is used to revert a database object to a previous version of itself.","id":36},
{"explanation":"SAVEPOINT is used to mark a specific instance in time or execution flow to which a future ROLLBACK can revert. COMMIT is used to save changes made by a set of DML statements. TRANSACTION is not a real SQL command. ROLLBACK is used to revert changes made by a set of DML statements. FLASHBACK is used to revert a database object to a previous version of itself.","id":37},
{"explanation":"A CONSTRAINT can be owned by a user so it is a schema object.","id":38},
{"explanation":"A SEQUENCE can be owned by a user so it is a schema object.","id":39},
{"explanation":"An INDEX can be owned by a user so it is a schema object.","id":40},
{"explanation":"A PRIVATE SYNONYM can be owned by a user so it is a schema object.","id":41},
{"explanation":"A TABLE can be owned by a user so it is a schema object.","id":42},
{"explanation":"A VIEW can be owned by a user so it is a schema object.","id":43},
{"explanation":"A ROLE cannot be owned by a user so it is non-schema object.","id":44},
{"explanation":"A ROLE cannot be owned by a user so it is non-schema object.","id":44},
{"explanation":"A USER cannot be owned by a user so it is non-schema object.","id":46},
{"explanation":"Official Oracle docs: \"A schema is a collection of database objects. A schema is owned by a database user and has the same name as that user. Schema objects are logical structures created by users. Objects such as tables or indexes hold data, or can consist of a definition only, such as a view or synonym.\" ","id":47},
{"explanation":"Official Oracle docs: \"Nonschema objects: Other types of objects are also stored in the database and can be created and manipulated with SQL but are not contained in a schema:\" ","id":48},
{"explanation":"PRIVATE SYNONYMs are schema objects that can be owned by users. USER objects themselves are not contained in any schema and are therefore nonschema objects. Because a USER object is nonschema, it cannot be owned by a USER object, including itself.","id":49},
{"explanation":"Official Oracle docs: \"The PUBLIC role is a special role that every database user account automatically has when the account is created. By default, it has no privileges granted to it, but it does have numerous grants, mostly to Java objects. You cannot drop the PUBLIC role, and a manual grant or revoke of this role has no meaning, because the user account will always assume this role. Because all database user accounts assume the PUBLIC role, it does not appear in the DBA_ROLES and SESSION_ROLES data dictionary views.\"","id":50},
{"explanation":"Oracle requires all unquoted object names to start with a letter, but they may also contain '$', '_' or '#'. All database objects must have a name, and in the rare cases where objects are created without a name the system generates a generic object name for them. Unquoted object names may not contain spaces (although quoted object names can). Unquoted object names are not case sensitive (although quoted object names are).","id":51}
{"explanation":"Quoted object names are case sensitive are case sensitive (although unquoted object names are not), Quoted object names must be references with their quotation marks -- a table with a quoted name \"MY_TABLE\" cannot be referenced by the unquoted string MY_TABLE. Quoted object names can contain spaces -- \"my table\" is a valid name. Quoted object names CAN contain reserved words and may start with any character.","id":52},
{"explanation":"A NAMESPACE is a logical boundary within the database which requires encompassing objects to have unique names. A CLUSTER is a schema object that contains data from one or more tables (and is not on the 1Z0-071 exam). A SCHEMA is a collection of logical structures of data, or schema objects. A DATABASE is a collection of data treated as a unit. A USER is a type of schema object.","id":53},
{"explanation":"Users and Roles are in the same non-schema namespace. Public synonyms are in their own non-schema namespace. Tables, Indexes and Constraints are all in separate schema namespaces.","id":54},
{"explanation":"Private Synonyms, Views, Sequences and Tables are all in the same schema namespace. Public Synonyms are in their own non-schema namespace.","id":55},
{"explanation":"Schema objects are in schema namespaces which are contained inside of schemas -- meaning, different schemas have different namespaces. Every USER object in the database must have a unique name because USER objects are in a non-schema namespace (with ROLEs). If they were in a schema namespace, you would be able to have two users with the same name as long as they were in different schemas. Only objects in the same namespace are prohibited from having the same name, so objects in different namespaces can clearly have the same name. INDEX and CONSTRAINT objects are in different namespaces (a user can own a PRIMARY KEY and a UNIQUE INDEX with the same name).","id":56},
{"explanation":"One NOT NULL constraint and one PRIMARY KEY constraint are created. It is important to note that PRIMARY KEY counts as a single constraint and not one UNIQUE INDEX plus one NOT NULL. Also, DEFAULT is not counted as a constraint.","id":57},
{"explanation":"DESC is used to return formatted details about a given table. SHOW is not a SQL command. EXPLAIN is not a SQL command. DETAILS is not a SQL command. HELP is not a SQL command.","id":58},
{"explanation":"The NUMBER data type has the optional parameters NUMBER(precision, scale). Precision is the total number of digits and Scale is the number of digits to the right of the decimal point that the number should be rounded to. When Precision is defined but Scale isn't, Scale = 0. You can specify a Scale with no Precision by using NUMBER(*, scale). When neither are defined, the number is taken as-is.\n\nIn this example, Precision = 2 and Scale = 0. So we are allowed 2 digits (5.67 becomes 5.6) but the number is rounded to 0 places after the decimal, making 5.6 round to 6 and giving us our answer.","id":59},
{"explanation":"The NUMBER data type has the optional parameters NUMBER(precision, scale). Precision is the total number of digits and Scale is the number of digits to the right of the decimal point that the number should be rounded to. When Precision is defined but Scale isn't, Scale = 0. You can specify a Scale with no Precision by using NUMBER(*, scale). When neither are defined, the number is taken as-is.\n\nBecause no Precision or Scale is defined, the number is stored as-is: 5.67.","id":60},
{"explanation":"The NUMBER data type has the optional parameters NUMBER(precision, scale). Precision is the total number of digits and Scale is the number of places to the right of the decimal point that the number should be rounded to. When Precision is defined but Scale isn't, Scale = 0. You can specify a Scale with no Precision by using NUMBER(*, scale). When neither are defined, the number is taken as-is.\n\nIn this example, our Precision = 5, so we are allowed to have 5 digits. However, our Scale = 2, so we round to two places to the right of the decimal, giving us our answer as 5.68.","id":61},
{"explanation":"The NUMBER data type has the optional parameters NUMBER(precision, scale). Precision is the total number of digits and Scale is the number of places to the right of the decimal point that the number should be rounded to. When Precision is defined but Scale isn't, Scale = 0. You can specify a Scale with no Precision by using NUMBER(*, scale). When neither are defined, the number is taken as-is.\n\nIn this example, our Precision = 4, so we are allowed to have 4 digits. However, our Scale = 1, so we round to 1 place after the decimal (5.67 rounds to 5.7).","id":62},
{"explanation":"Official Oracle docs: \"The DATE datatype stores point-in-time values (dates and times) in a table. The DATE datatype stores the year (including the century), the month, the day, the hours, the minutes, and the seconds (after midnight).\"","id":63},
{"explanation":"OBLOB does not exist. BLOB stands for Binary Large Object and stores any kind of data in binary format. CLOB stands for Character Large Object and stores large string data in the database character set format. NCLOB stands for National Character Set Large Object and stores large string data in the National Character Set format.","id":64},
{"explanation":"Official Oracle docs regarding BLOBs: \"Stores any kind of data in binary format. Typically used for multimedia data such as images, audio, and video.\"\n\nCLOB stands for Character Large Object and stores large string data in the database character set format. OBJECT is not a data type. IMAGE is not a data type. FILE is not a data type.","id":65},
{"explanation":"There is no such thing as a CREATE CONSTRAINT statement. ","id":66},
{"explanation":"There is no such thing as a CREATE CONSTRAINT statement. NOT NULL constraints cannot be added by the ALTER TABLE ADD CONSTRAINT syntax - They must use ALTER TABLE MODIFY <column>. NOT NULL constraints can only be added in a CREATE TABLE statement when they are inline with the respective columns (e.g. \"my_num NUMBER NOT NULL\") and they cannot be added out-of-line with their respective columns (where \"CONSTRAINT my_pk PRIMARY KEY (my_num)\" is valid to include in a CREATE TABLE statement to create a PRIMARY KEY, there is no such statement for NOT NULL constraints.)","id":67},
{"explanation":"A UNIQUE constraint ensures that a set of specified columns will never be repeated by two rows in the same table. A FOREIGN KEY constraint ensures that values in one table exist in another table. A NOT NULL constraint ensures that the column value is never NULL. A CHECK constraint ensures that they column value adheres to a defined custom logic. /*REF CONSTRAINT EXPLANATION*/","id":69},
{"explanation":"A PRIMARY KEY ensures that its column combinations are unique and that none of their values are NULL. \n\nA FOREIGN KEY constraint ensures that values in one table exist in another table. \n\nThere is no such thing as a LOCAL KEY constraint.\n\n/*REF CONSTRAINT EXPLANATION*/\n\nA CHECK constraint ensures that they column value adheres to a defined custom logic.","id":70},
{"explanation":"A FOREIGN KEY constraint ensures that values in one table exist in another table, thus preserving referential integrity.\n\nA NOT NULL constraint ensures that the column value is never NULL.\n\nA CHECK constraint ensures that they column value adheres to a defined custom logic.\n\nA UNIQUE constraint ensures that a set of specified columns will never be repeated by two rows in the same table.\n\nA PRIMARY KEY constraint ensures that a certain column combination is always unique and that none of its values are NULL.","id":71},
{"explanation":"Without an ON DELETE clause in the FOREIGN KEY definition, an exception will be thrown when trying to delete rows in the referenced parent table which map to rows in the constrained child table.\n\nON DELETE CASCADE will delete the rows in the constrained child table as well.\n\nON DELETE SET NULL will set the value in the constrained child rows to NULL.\n\nON DELETE RESTRICT will reject the delete and throw an exception -- that is, it will do the same as if you did not include an ON DELETE clause.\n\nON DELETE PURGE is invalid syntax.\n\nON DELETE SET DEFAULT is valid syntax but will do nothing.\n\nOracle Official docs: \"CASCADE: Delete or update the row from the parent table, and automatically delete or update the matching rows in the child table. Both ON DELETE CASCADE and ON UPDATE CASCADE are supported. Between two tables, do not define several ON UPDATE CASCADE clauses that act on the same column in the parent table or in the child table.\n\nSET NULL: Delete or update the row from the parent table, and set the foreign key column or columns in the child table to NULL. Both ON DELETE SET NULL and ON UPDATE SET NULL clauses are supported.\n\nRESTRICT: Rejects the delete or update operation for the parent table. Specifying RESTRICT (or NO ACTION) is the same as omitting the ON DELETE or ON UPDATE clause.\n\nSET DEFAULT: This action is recognized by the MySQL parser, but InnoDB rejects table definitions containing ON DELETE SET DEFAULT or ON UPDATE SET DEFAULT clauses.\"\n","id":72},
{"explanation":"Without an ON DELETE clause in the FOREIGN KEY definition, an exception will be thrown when trying to delete rows in the referenced parent table which map to rows in the constrained child table.\n\nON DELETE SET NULL will set the value in the constrained child rows to NULL.\n\nON DELETE CASCADE will delete the rows in the constrained child table as well.\n\nON DELETE RESTRICT will reject the delete and throw an exception -- that is, it will do the same as if you did not include an ON DELETE clause.\n\nON DELETE NULLIFY is invalid syntax.\n\nON DELETE SET DEFAULT is valid syntax but will do nothing.\n\nOracle Official docs: \"CASCADE: Delete or update the row from the parent table, and automatically delete or update the matching rows in the child table. Both ON DELETE CASCADE and ON UPDATE CASCADE are supported. Between two tables, do not define several ON UPDATE CASCADE clauses that act on the same column in the parent table or in the child table.\n\nSET NULL: Delete or update the row from the parent table, and set the foreign key column or columns in the child table to NULL. Both ON DELETE SET NULL and ON UPDATE SET NULL clauses are supported.\n\nRESTRICT: Rejects the delete or update operation for the parent table. Specifying RESTRICT (or NO ACTION) is the same as omitting the ON DELETE or ON UPDATE clause.\n\nSET DEFAULT: This action is recognized by the MySQL parser, but InnoDB rejects table definitions containing ON DELETE SET DEFAULT or ON UPDATE SET DEFAULT clauses.\"\n","id":73},
{"explanation":"Without an ON DELETE clause in the FOREIGN KEY definition, an exception will be thrown when trying to delete rows in the referenced parent table which map to rows in the constrained child table.\n\nON DELETE RESTRICT will reject the delete and throw an exception -- that is, it will do the same as if you did not include an ON DELETE clause.\n\nON DELETE SET NULL will set the value in the constrained child rows to NULL.\n\nON DELETE CASCADE will delete the rows in the constrained child table as well.\n\nON DELETE THROW EXCEPTION is invalid syntax.\n\nON DELETE SET DEFAULT is valid syntax but will do nothing.\n\nOracle Official docs: \"CASCADE: Delete or update the row from the parent table, and automatically delete or update the matching rows in the child table. Both ON DELETE CASCADE and ON UPDATE CASCADE are supported. Between two tables, do not define several ON UPDATE CASCADE clauses that act on the same column in the parent table or in the child table.\n\nSET NULL: Delete or update the row from the parent table, and set the foreign key column or columns in the child table to NULL. Both ON DELETE SET NULL and ON UPDATE SET NULL clauses are supported.\n\nRESTRICT: Rejects the delete or update operation for the parent table. Specifying RESTRICT (or NO ACTION) is the same as omitting the ON DELETE or ON UPDATE clause.\n\nSET DEFAULT: This action is recognized by the MySQL parser, but InnoDB rejects table definitions containing ON DELETE SET DEFAULT or ON UPDATE SET DEFAULT clauses.\"\n","id":74},
{"explanation":"0 will throw a check constraint errors because it is not \"IN (1,2)\".\n\n1 is \"IN (1,2)\" so it would not throw a check constraint error.\n\n2 is \"IN (1,2)\" so it would not throw a check constraint error.\n\n'my_value' will throw an invalid number error, not a check constraint error.\n\nThe \"my_status IN (1,2)\" is the equivalent of \"my_status = 1 OR my_status = 2\". When my_status = NULL, the logic becomes \"NULL = 1 OR NULL = 2\". NULL = <anything> always evaluates to UNKNOWN. Check constraint errors are only thrown if the logic evaluates to FALSE. Because a NULL input causes the CHECK condition to evaluate to UNKNOWN instead of FALSE, no errors are thrown and we are allowed to insert the value.\n\n","id":75},
{"explanation":"3 will throw a check constraint errors because it causes the \"BETWEEN 1 AND 2\" statement to evaluate to FALSE.\n\nThe BETWEEN statement is inclusive, so an input of either 1 or 2 causes \"BETWEEN 1 AND 2\" to evaluate to TRUE, thus throwing no errors.\n\n\nThe NUMBER data type has the optional parameters NUMBER(precision, scale). Precision is the total number of digits and Scale is the number of digits to the right of the decimal point that the number should be rounded to. When Precision is defined but Scale isn't, Scale = 0. You can specify a Scale with no Precision by using NUMBER(*, scale). When neither are defined, the number is taken as-is.  my_status is of data type NUMBER(1). This means that Precision = 1 and Scale = 0. Because precision = 1, we are allowed only 1 digit, but because scale = 0, we round to the 0th decimal place, causing 1.5 to round up to 2. An input of 2 causes \"BETWEEN 1 AND 2\" to evaluate to TRUE, thus throwing no errors.\n\nThe \"my_status BETWEEN 1 AND 2\" statement is the equivalent of \"my_status >= 1 AND my_status <= 2\". When my_status = NULL, the logic becomes \"NULL >= 1 AND NULL <= 2\". Using the <= or >= relational operators with a NULL argument always evaluates to UNKNOWN. Check constraint errors are only thrown if the logic evaluates to FALSE. Because a NULL input causes the CHECK condition to evaluate to UNKNOWN instead of FALSE, no errors are thrown and we are allowed to insert the value.","id":76},
{"explanation":"None of the columns in UNIQUE, PRIMARY KEY or FOREIGN KEY constraints can be a LOB type, LONG, LONG RAW, VARRAY, NESTED TABLE, BFILE, REF, TIMESTAMP WITH TIME ZONE, or a user-defined type.","id":77},
{"explanation":"Attempting to drop a column from a references parent table in a FOREIGN KEY relationship will throw an error if CASCADE CONSTRAINTS is not added to the DROP COLUMN clause (which will then drop the FOREIGN KEY constraint).\n\nHowever, trying to drop a column from the constrained child table is no problem and does not require CASCADE CONSTRAINTS, as it will automatically drop the column and the FOREIGN KEY constraint.\n\nALTER TABLE DROP (<column_1>, <column_2>...); is valid syntax and can be used to drop multiple columns.\n\nYou cannot drop all columns in a table; attempting to do so will throw an error.","id":78},
{"explanation":"The correct answer is 2: one CHECK constraint and one PRIMARY KEY constraint.\n\nThe code does not throw an error: you can freely drop FOREIGN KEY constrained columns on the CHILD table (my_table_2), but not on the PARENT table (my_table_1). If you were to drop the column from my_table_1, you would have required a CASCADE CONSTRAINT clause, but for my_table_2 the column dropping statement works without error.\n\nPrior to dropping my_status, my_table_2 had 5 constraints: PRIMARY KEY and CHECK constraints on my_id and NOT NULL, FOREIGN KEY and UNIQUE constraints on my_status. When my_status was dropped the latter 3 constraints were dropped with it, leaving only the constraints on my_id.","id":79},
{"explanation":"The execution fails because my_status is part of a multicolumn constraint. In fact, it is part of 2 multicolumn constraints: my_fk and my_pk2. However, if my_status had been in just one, execution still would have failed.\n\nIn order to drop my_status, you would need to include a CASCADE CONSTRAINTS clause, which would have dropped both my_fk and my_pk2, leaving no constraints on my_table_2.","id":80},
{"explanation":"Because CASCADE CONSTRAINTS was added to the DROP COLUMN statement, the query executes successfully. Had CASCADE CONSTRAINTS not been included, the query would have failed because columns used in multicolumn constraints cannot be dropped.\n\nThe CASCADE CONSTRAINTS statement caused my_fk and my_pk2 to be dropped because they referenced my_status. Afterwards, my_table_2 was left with no more constraints.","id":81},
{"explanation":"Setting a column to be UNUSED makes it permanently unusable. The statement cannot be reversed, not even by ROLLBACK or an ALTER TABLE statement.\n\nAn UNUSED column's name is deleted so a new column can use that name, but they still count towards the table's maximum column limit. Constraints and indices are automatically dropped. \n\nOfficial Oracle docs: \"If you are concerned about the length of time it could take to drop column data from all of the rows in a large table, you can use the ALTER TABLE...SET UNUSED statement. This statement marks one or more columns as unused, but does not actually remove the target column data or restore the disk space occupied by these columns. However, a column that is marked as unused is not displayed in queries or data dictionary views, and its name is removed so that a new column can reuse that name. All constraints, indexes, and statistics defined on the column are also removed.\"","id":82},

//error in 83 -- columns can be set unused if they are constrained by a single column constraint. Only stopped by multicolumn constraints

{"explanation":"Setting a column to be UNUSED makes it permanently unusable and cannot be recovered. The statement cannot be reversed, not even by ROLLBACK or an ALTER TABLE statement.\n\nA column that has been set UNUSED can be dropped at a later date using the ALTER TABLE... DROP UNUSED COLUMNS command.\n\nA column cannot be set unused if it is part of a multicolumn constraint, such as a PRIMARY KEY on more than one column. However, it can be set unused if it is part of a single column constraint, such as NOT NULL.\n\nAny number of columns can be set as UNUSED.\n\nYou cannot set a table's final column to be unused. Every table must have at least one usable column.\n\nOfficial Oracle docs: \"If you are concerned about the length of time it could take to drop column data from all of the rows in a large table, you can use the ALTER TABLE...SET UNUSED statement. This statement marks one or more columns as unused, but does not actually remove the target column data or restore the disk space occupied by these columns. However, a column that is marked as unused is not displayed in queries or data dictionary views, and its name is removed so that a new column can reuse that name. All constraints, indexes, and statistics defined on the column are also removed.\"","id":83},
{"explanation":"External tables allow you to query data stored outside the database as if were stored in a table. The metadata which defines the structure is stored inside the database, while the actual data is stored externally.\n\nA VIEW is a table-like object which is defined only logically, by a query, and contains no physical data.\n\nA CLUSTER is a schema object that contains data from one or more tables (and is not on the 1Z0-071 exam).\n\nA DIRECTORY defines a location on the server file system which external resources can be stored.\n\nThere is no such Oracle object as a DISTRIBUTED TABLE.","id":84},

//ambiguity in 85 -- external tables can call SET COLUMN UNUSED but it is equivalent to DROP COLUMN. External Tables are also not read-only. After 10g, they were writable
// more external table questions
{"explanation":"You cannot add a LONG, LOB, or object type column to an EXTERNAL TABLE or change the datatype of an EXTERNAL TABLE's column to any of these datatypes.\n\nYou cannot add a constraint to an external table.\n\nYou CAN add, drop or modify columns of an EXTERNAL TABLE. \n\nYou can use the SET COLUMN UNUSED command on an external table, however the command does not actually set the column to be UNUSED and instead functions exactly as a DROP COLUMN command.\n\nIndexes cannot be made on EXTERNAL TABLEs. From the official Oracle docs: \"You can, for example, select, join, or sort external table data. You can also create views and synonyms for external tables. However, no DML operations (UPDATE, INSERT, or DELETE) are possible, and no indexes can be created, on external tables.\"\n\nPrior to Oracle 10g, EXTERNAL TABLEs were read-only. However, they became writable post-10g. That being said, Oracle official documents explicitly state \"Oracle Database allows you read-only access to data in external tables\", which clearly conveys that they cannot be written to. However, Oracle official documents also state \"The second access driver, ORACLE_DATAPUMP, lets you unload dataâ€”that is, read data from the database and insert it into an external table\", which clearly states that data can be inserted into the EXTERNAL TABLE only through the ORACLE_DATAPUMP driver. You definitely can insert data using ORACLE_DATAPUMP, which must not invalidate Oracle's label of \"read-only\". Be very careful of this ambiguity when taking the exam.\n\n","id":85},
{"explanation":"From the official Oracle docs: \"You can, for example, select, join, or sort external table data. You can also create views and synonyms for external tables. However, no DML operations (UPDATE, INSERT, or DELETE) are possible, and no indexes can be created, on external tables.\"\n\nWhile ALTER TABLE ... SET UNUSED is allowed on EXTERNAL TABLEs, it functions exactly the same as DROP COLUMN.","id":86},
{"explanation":"You cannot add a LONG, LOB, or object type column to an EXTERNAL TABLE or change the datatype of an EXTERNAL TABLE column to any of these datatypes.","id":87},
{"explanation":"A DIRECTORY defines a location on the server file system which external resources can be stored.\n\nEXTERNAL TABLES allow you to query data stored outside the database as if were stored in a table. The metadata which defines the structure is stored inside the database, while the actual data is stored externally.\n\nThe is no such Oracle object as a FILE (however, there are PFILE and SPFILE objects which are not covered on the exam).\n\nThe is no such Oracle object as a FILEPATH.\n\n\nThe is no such Oracle object as a LOCATION.","id":88},
{"explanation":"The only object which can support a CONSTRAINT is a TABLE. This excludes the EXTERNAL TABLE object, which does not support the use of CONTRAINTs.","id":89},


//include this: VARCHAR is reserved by Oracle to support distinction between NULL and empty string in future, as ANSI standard prescribes.
{"explanation":"Unquoted object names must always start with a letter, so \"CREATE TABLE $my_table...\" is invalid.\n\n\"$ create table\" and \"my table\" are valid object names ONLY because they are quoted.\n\nIf you were wondering, all column definitions are correct. A NUMBER data type definition is allowed between 0 and 2 optional parameters: NUMBER(precision, scale). A VARCHAR2 data type definition requires a mandatory parameter: VARCHAR2(size).","id":90},
{"explanation":"A CONSTRAINT has no corresponding CREATE statement. You can only instantiate a CONSTRAINT in a CREATE TABLE or ALTER TABLE statement.\n\nThere is no ROW database object and thus has no corresponding CREATE statement.\n","id":91},
{"explanation":"On line 1, three objects will be created: a TABLE named my_table, a CONSTRAINT named my_obj and an INDEX named my_obj (The PRIMARY KEY instantiation creates the latter two with the same name). CONSTRAINT and INDEX objects have different namespaces, so there is no conflict.\n\nOn line 2, a VIEW will be created called my_obj. Even though we already have a CONSTRAINT named my_obj AND an INDEX named my_obj, VIEW objects are in a different namespace than CONSTRAINT and INDEX objects, so there is no conflict. \n\nOn line 3, an INDEX called my#other#obj is created. Because we have no other objects created with this name, there is obviously no conflict. (And if you were wondering, my#other#obj is indeed a valid object name.)\n\nOn line 4, a TABLE is created with the name my#other#obj. TABLE objects and INDEX objects are in different namespaces, so there is no conflict.","id":92},
{"explanation":"On line 1, we create a TABLE object named my_obj.\n\nOn line 2, we create two objects: a CONSTRAINT object named my_obj and an INDEX object also named my_obj (The PRIMARY KEY instantiation creates the latter two with the same name). Even though we already have a TABLE named my_obj, TABLES, INDEXES and CONSTRAINTS are all in different namespaces, so there is no conflict.\n\nOn line 3, we create a VIEW named my_obj. VIEW objects and TABLE objects share a namespace when inside the same schema, so there is a naming conflict with the TABLE my_obj that was created in line 1.\n\n","id":93},
{"explanation":"TABLE and INDEX objects have different namespaces, so there is no conflict.","id":94},
{"explanation":"On line 1, we create a TABLE object named my_obj.\n\nOn line 2, we create 2 objects named my_obj: a CONSTRAINT object and an INDEX object (The PRIMARY KEY instantiation creates the latter two with the same name). TABLES, INDEXES and CONSTRAINTS are all in different namespaces, so there is no conflict.\n\nOn line 3, we attempt to create an INDEX named my_obj. However, we have already created an INDEX named my_obj in the PRIMARY KEY instantiation in line 2, so there is a conflict.","id":95},
{"explanation":"On line 1, we create a TABLE object named my_obj.\n\nOn line 2, we create a CONSTRAINT object called my_obj. CONSTRAINTS and TABLES are in different namespaces, so there is no conflict.\n\nOn line 3, we create an INDEX named my_obj. TABLES, CONSTRAINTS and INDEXES are all in different namespaces, so there is no conflict.","id":96},
{"explanation":"On line 1, we create a TABLE object named my_obj.\n\nOn line 2, we create 2 objects named my_obj: a CONSTRAINT object and an INDEX object (The PRIMARY KEY instantiation creates the latter two with the same name). TABLES, INDEXES and CONSTRAINTS are all in different namespaces, so there is no conflict.","id":97},
{"explanation":"ROLES and USERS share the same nonschema namespace. There are no other object types in this namespace.\n\nPUBLIC SYNONYMS are in their own nonschema namespaces separate from ROLES and USERS.\n\nROLES are always nonschema objects; in fact, there are no objects which can be either schema or nonschema.","id":98},
{"explanation":"This is a perfectly valid CREATE TABLE statement. The only possible concerns might be the data type definitions of CHAR(2) and VARCHAR2(10). CHAR data type definitions take in 1 optional parameter: CHAR(size). VARCHAR2 data type definitions take in 1 mandatory paramater: VARCHAR2(size).","id":99},
{"explanation":"LOB objects cannot by used as primary keys, so line 2 is invalid. \n\nVARCHAR2 data type definitions take in a mandatory parameter: VARCHAR2(size). This is missing in line 4, so that line is incorrect.","id":100},
{"explanation":"LOB objects cannot have UNIQUE constraints applied to them, so line 3 is invalid.\n\nAlso, if you were wondering, it is valid for a NUMBER data type definition to have a negative Scale parameter, as is present in line 2. ","id":101},
{"explanation":"A PRIMARY KEY constraint enforces non-nullability, so \"CREATE TABLE my_table (my_data CHAR, CONSTRAINT my_c PRIMARY KEY (my_data));\" is correct.\n\nThe expression \"my_data IS NOT NULL\" evaluates to FALSE when my_data = NULL, so \"CREATE TABLE my_table (my_data CHAR, CONSTRAINT my_c CHECK (my_data IS NOT NULL));\" is correct.\n\nNOT NULL constraints cannot be created out-of-line in a CREATE TABLE statement, so \"CREATE TABLE my_table (my_data CHAR, CONSTRAINT my_c NOT NULL (my_data));\" is incorrect.\n\nUNIQUE constraints do not enforce non-nullability, so \"CREATE TABLE my_table (my_data CHAR, CONSTRAINT my_c UNIQUE (my_data));\" is incorrect.","id":102},
{"explanation":"LOB objects cannot by used as primary keys, so line 2 is invalid. \n\nVARCHAR2 data type definitions take in a mandatory parameter: VARCHAR2(size). This is missing in line 4, so that line is incorrect.","id":103},

// ambiguity in 104 -- make "It keeps data in the table's indexes in tact." less ambiguous. Change to: "It does not truncate any associated indexes"
// also take out underscore in FLASHBACK TABLE

{"explanation":"TRUNCATE is a DDL statement at the table level and fires no DML triggers, which are at the row level. \n\nTRUNCATE TABLE will remove all rows in a table, but you can also TRUNCATE partitions and subpartitions of a table by using a different command.\n\nOracle official docs: \"when the table is truncated, the index is also truncated, and a new high water mark is calculated for the index segment.\"\n\nOracle official docs: \"You cannot roll back a TRUNCATE TABLE statement, nor can you use a FLASHBACK TABLE statement to retrieve the contents of a table that has been truncated.\"","id":104},

// in 105, remove the underscores from DROP_ANY_TABLE. 
//Also change "It requires the DROP_ANY_TABLE privilege." to "If the table is not in your schema, the statement requires the DROP_ANY_TABLE privilege."
// also change "It deletes rows even if there is an integrity constraint violation." to "It deletes rows even if there is an referential integirty violation."
{"explanation":"To truncate a table, the table must be in your schema or you must have DROP ANY TABLE system privilege.\n\nTRUNCATE TABLE is a DDL statement and therefore performs an implicit commit.\n\nThe TABLE keyword is required when trying to TRUNCATE a table. Attempting to execute TRUNCATE <table_name> is a syntax error.\n\nOracle official docs: \"You cannot truncate the parent table of an enabled foreign key constraint. You must disable the constraint before truncating the table. An exception is that you can truncate the table if the integrity constraint is self-referential.\"\n\nOracle official docs: \"You cannot roll back a TRUNCATE TABLE statement, nor can you use a FLASHBACK TABLE statement to retrieve the contents of a table that has been truncated.\"","id":105},
{"explanation":"You cannot truncate the parent table of an enabled foreign key constraint, so line 7 fails. However, the TRUNCATE command performs an implicit commit even in the case of failure, so line 6 is now committed.","id":106},
{"explanation":"Line 6 inserts the number 1 into my_table_1.my_id. Because there is no corresponding row in my_table_2.my_id which references that row, then there is no referential integrity error. If there had been an \"INSERT INTO my_table_2 VALUES (1);\" command between lines 6 and 7, then there would have been an integrity violation on \"DELETE FROM my_table_1;\" due to the FOREIGN KEY constraint on my_table_2.\n\n\nDELETE is a DML statement and as such does not perform an implicit commit. Therefore, line 6 has not been committed after line 7.","id":107},
{"explanation":"TRUNCATE statements fail only when performed on the PARENT table of a FOREIGN KEY constraint. Because line 8 truncates on my_table_2, the child table in the referential relationship, it will not throw an error. Had the TRUNCATE statement been on my_table_1, line 8 would have thrown an error.\n\nTRUNCATE is a DDL statement and as such performs an implicit commit. So once line 8 executes, the DML inserts at lines 6 and 7 are committed. Note that TRUNCATE implicitly commits even if the statement fails, so line 6 would have been committed even if there had been a referential constraint.","id":108},


//in 109, make "The inserted value data types only have to be compatible with the table's columns, not identical." less ambiguous
//take out "The "VALUES" keyword is optional."
{"explanation":"If you leave out columns in your INSERT INTO... VALUES... statement, all excluded columns will be set to null. Therefore, Nullable columns are optional in an INSERT INTO... VALUES... statement, while Non-Nullable columns are mandatory and would throw a \"Cannot insert NULL\" exception if excluded.\n\nThe values that are inserted using an INSERT INTO... VALUES... command will automatically convert to the data types of the table's columns (as long as the two data types are compatible).\n\nINTO is a mandatory keyword. Excluding it will cause a syntax failure.\n\nData definition language (DDL) statements let you manipulate database objects or privileges. Data manipulation language (DML) statements access and manipulate data in existing schema objects. Because INSERT is used to add data to a table, it is considered a DML command, not a DDL command.","id":109},
{"explanation":"The PRIMARY KEY on my_id instantiated on line 2 enforces uniqueness on that column. So once line 4 already inserts 1 into my_table.my_id, line 5 will fail when it tries to insert the same value.\n\nThere are no COMMIT or DDL statements at or after line 5, so it could not be committed.","id":110},
{"explanation":"This question concerns the fact that line 4 inserts a CHAR value into my_id, which is has NUMBER data type. Because '1' is a character representation of a number, Oracle can and will implicitly convert it into a NUMBER data type before inserting it. Therefore, there is no error.\n\nThere are no COMMIT or DDL statements at or after line 5, so it could not be committed.","id":111},
{"explanation":"This question concerns the fact that line 4 inserts a NUMBER value into my_id, which is has CHAR data type. Oracle can and will implicitly convert the NUMBER value 1 into the CHAR value '1' before inserting it. Because line 3 already has inserted the CHAR value '1' on line 3, this violates the in-line UNIQUE constraint defined on line 2, causing line 4 to fail.\n\nThere are no COMMIT or DDL statements at or after line 4, so it could not be committed.","id":112},
{"explanation":"The CHECK constraint in line 2 evaluates an IN condition on two NUMBER values: 1 and 2. When line 3 attempts to insert the CHAR value '1' into my_id, the \"my_id IN (1,2)\" clause evaluates ('1' = 1 OR '1' = 2). Note that Oracle's implicit type conversion causes '1' = 1 to evaluate to true, so the CHECK constraint does not fail. \n\nThere are no COMMIT or DDL statements at or after line 3, so it could not be committed.","id":113},
{"explanation":"Line 3 fails because you are missing the VALUES keyword.","id":114},

//115 clear up ambiguity in "After line 6, there are two records in my_table."
{"explanation":"Official Oracle docs: \"Unless a NOT NULL constraint is also defined, a null always satisfies a unique key constraint. Thus, columns with both unique key constraints and NOT NULL constraints are typical. This combination forces the user to enter values in the unique key and eliminates the possibility that new row data conflicts with existing row data.\"\n\nKeep in mind that NULL = NULL never evaluates to TRUE or FALSE, but rather to UNKNOWN.\n\nAfter line 6, there are 3 rows in the table: two NULL rows and one row containing 'A'.\n\nThere are no COMMIT or DDL statements at or after line 3, so it could not be committed.","id":115},
{"explanation":"An UPDATE statement can only take one table as a parameter. \n\nIf an UPDATE statement changes one row to violate any constraint condition, then the entire UPDATE statement will not be accepted and it will make no modifications to the table.\n\nIf an UPDATE statement matches to 0 rows or updates 0 rows, no exception will be thrown.\n\nAn UPDATE statement, unlike an INSERT statement, does not need to specify values for all NOT NULL columns.\n\nUPDATE is a DML statement and therefore does not automatically commit after execution.\n\n","id":116},
{"explanation":"DML statements, such as INSERT, UPDATE and MERGE can be undone using a ROLLBACK command.\n\nDDL statements such as TRUNCATE and CREATE implicitly commit after execution and cannot be reverted with the ROLLBACK command.","id":117},
{"explanation":"At line 3, the value 'A' is inserted into my_id.\n\nAt line 4, a COMMIT is executed, saving the DML change in line 3.\n\nAt line 5, the value 'B' is inserted into my_id.\n\nAt line 6, a ROLLBACK is executed, reverting the DML changes in line 5. The changes in line 3 have already been committed by line 4, so they are not reverted and 'A' is still stored in the table.\n\nLine 7 attempts to insert 'A' into my_id, but because 'A' already exists in the table this violates the UNIQUE constraint on my_id, causing an error.\n","id":118},
{"explanation":"This question concerns the DDL status of the GRANT and CREATE USER statements.\n\nThe GRANT statement on line 5 performs an implicit commit, saving the 'A' value inserted in line 4 and causing it to not be reverted by the ROLLBACK on line 6. Thus, when line 7 attempts to insert 'A' into my_id, the UNIQUE constraint on that column is violates, causing an error.\n\nLine 8 attempts to create a USER named my_user, even though we already created a USER object with the same name in line 1. The ROLLBACK in line 6 does not undo the CREATE USER statement in line 1 because (a) CREATE USER is a DDL statement and can't be rolled back and (b) there is an implicit commit at line 5 so even if CREATE USER were a DML statement, line 1 would still be saved.","id":119},
{"explanation":"At line 3, we insert 'A' into my_table.my_id.\n\nAt line 4, we DROP my_table. DROP is a DDL statement so it performs an implicit commit.\n\nAt line 5, we call ROLLBACK. This doesn't revert our DROP TABLE command on line 4 because DROP TABLE is a DDL statement, so my_table is still dropped,\n\nLine 6 attempts to insert 'A' into my_table.my_id. However, because my_table was dropped in line 4, this causes an error.","id":120},
{"explanation":"At line 3, we insert 'A' into my_table.my_id.\n\nAt line 4, we DROP my_table. DROP is a DDL statement so it performs an implicit commit.\n\nAt line 5, we call ROLLBACK. This doesn't revert our DROP TABLE command on line 4 because DROP TABLE is a DDL statement, so my_table is still dropped,\n\nLine 6 attempts to insert 'A' into my_table.my_id. However, because my_table was dropped in line 4, this causes an error.","id":120},

//error at 121: Line 6 does not fail
{"explanation":"At line 4, the mandatory keyword \"TABLE\" is missing. This means that the TRUNCATE command isn't even recognized so there is no implicit commit.\n\nLine 3 is reverted by the ROLLBACK at line 5 so there is no unique constraint error at line 6.","id":121},
{"explanation":"You cannot truncate a table which is the parent in a FOREIGN KEY relationship, so line 7 fails. However, even though it fails, the TRUNCATE command still makes an implicit commit.\n\nBecause line 7 causes an implicit commit, the DML changes in line 6 are not reverse by the ROLLBACK in line 8. Therefore the attempted INSERT in line 9 will cause a unique constraint violation.","id":122},

//misspelling at 123: nonexistant should be nonexistent
{"explanation":"There is no such table as nonexistent_table, so the TRUNCATE at line 4 fails. However, even though it fails, the TRUNCATE command still makes an implicit commit.\n\nBecause line 4 causes an implicit commit, the DML changes in line 3 are not reverse by the ROLLBACK in line 5. Therefore the attempted INSERT in line 3 will cause a unique constraint violation.","id":123},
{"explanation":"The ALTER TABLE command a line 6 is a DDL statement which causes an implicit commit.\n\nBecause line 4 causes an implicit commit, the DML changes in line 3 are not reverse by the ROLLBACK in line 5. Therefore the attempted INSERT in line 6 will cause a unique constraint violation.","id":124}
{"explanation":"The INSERT at line 6 is reverted by the ROLLBACK at line 7, so there is no unique constraint violation when the INSERT at line 9 is executed.","id":125},
{"explanation":"The ALTER TABLE command at line 7 causes an implicit commit because it is a DDL statement. Therefore, by the time we execute the ROLLBACK at line 8, the savepoint MARK1 has been invalidated and will throw a \"savepoint 'MARK1' never established in this session or is invalid\" exception. \n\nBecause the rollback did not succeed, and also because of the commit at line 7, the DML INSERT at line 6 has been saved. So the INSERT at line 9 will throw a UNIQUE constraint violation error.\n","id":126},
{"explanation":"There is no such table as nonexistent_table, so the TRUNCATE at line 5 fails. However, even though it fails, the TRUNCATE command still makes an implicit commit.\n\nBecause of the commit at line 5, the savepoint MARK1 has been invalidated, so line 6 will throw a \"savepoint 'MARK1' never established in this session or is invalid\" exception.\n\nBecause the DML statement at line 4 was committed by line 5, line 7 will violate the unique constraint defined in line 2. ","id":127},
{"explanation":"There is no commit between line 3 and line 5 so the ROLLBACK command will execute successfully and revert the DML statement at line 4.\n\nBecause the INSERT at line 4 has been reverted, the INSERT at line 6 will not throw a unique constraint violation error.","id":128},
{"explanation":"The CREATE TABLE statement is perfectly valid. The only concern might be that 1234 is being inserted into a VARCHAR2(10) data type, but Oracle would implicitly convert the entry.","id":129},
{"explanation":"The mandatory VALUES keyword is missing.","id":130},
{"explanation":"he statements are perfectly valid. Both my_id and my_name enforce uniqueness, and the two INSERT statements have different values for these columns.\n\nThere might be a concern that 1234 is being inserted into a VARCHAR2(10) data type, but Oracle would implicitly convert the entry.","id":131},
{"explanation":"WHERE clauses are optional. \n\nVALUES is not mandatory when not supplying hard-coded values to be inserted. INSERT INTO <table> (<select query>); is valid syntax.\n\nINSERT and INTO are both mandatory keywords.","id":132},


//error at 133: WHERE is not required for delete
{"explanation":"Not only is TABLE not required, but including it would be invalid syntax.\n\nFROM is an optional keyword. DELETE <table_name> is valid syntax.\n\nWHERE is optional because the WHERE clause in a DELETE statement is optional.\n\nDELETE is mandatory.","id":133},
{"explanation":"WHERE is optional because the WHERE clause in a UPDATE statement is optional.\n\nIN is a conditional operator and is never required.\n\nUPDATE and SET are both required.","id":134},
{"explanation":"ORDER BY statements take priority in their column lists from left to right, so this statement will sort by my_data1 first and then by my_data2.\n\nIf ASC or DESC is not defined, then the defaulted sort is ASC. Therefore, we are sorting the data first by my_data1 ASC and then by my_data2 DESC.\n\nIt is perfectly allowed to ORDER BY some columns which are not in your SELECT list.\n\nGROUP BY is definitely not necessary in this query since we are returning only one column, so there is no chance of an aggregation level conflict.\n\n","id":135},
{"explanation":"Certain expressions are allowed in the ORDER BY clause, such as \"ORDER BY my_data2 + 1\", but LIKE is not allowed. Even if it were, the question's usage is incorrect and makes no sense.\n\nIt is perfectly allowed to ORDER BY some columns which are not in your SELECT list.\n\nGROUP BY is definitely not necessary in this query since we are returning only one column, so there is no chance of an aggregation level conflict.\n\n","id":136},


//errors at  137

{"explanation":"ORDER BY statements are always optional. \n\nIt is perfectly allowed to ORDER BY some columns which are not in your SELECT list.\n\n","id":138},
{"explanation":"The clause \"WHERE my_data IN ('my_data1', 'my_data2', '%data3')\" is not a LIKE statement. It is equivalent to (my_data = 'my_data1' OR my_data  = 'my_data2' OR my_data = '%data3'). \n\n'my_data3' = '%data3' evaluates to FALSE. 'my_data3' LIKE '%data3'  would evaluate to TRUE, but that is not in the WHERE clause.\n\nTherefore, the select statement returns two rows: 'my_data1' and 'my_data2'.","id":139},


//maybe at some point include more practice on ascii table weights, and general sorting weight information for all datatypes
//add some practice on oracle boolean truth tables with unknown
{"explanation":"A descending order means that the highest ranking values are returned first.\n\nOracle sorts based on ASCII weights. In ASCII, all uppercase letters come before all lowercase letters and therefore have  lower weights. So 'me' would return before 'You' in a descending sort because a lowercase 'm' has a higher weight than an uppercase 'Y'.\n\nOracle weights later dates higher, so January 2nd 2000 returns before January 1st 2000 in a descending sort.\n\n'You' is weighted higher than 'Me' in a descending sort because uppercase 'Y' comes after uppercase 'M'. Therefore, 'Me' does not return before 'You'.\n\nIt is important to realize that '100' and '50' are taken as CHARACTER data, not numbers, and as such are weighted only by their first character. Because '5' obviously comes after '1', '50' would return before '100' in a descending sort.\n\nNUMBER values take their weight as straight numerical comparisons, so 2 obviously weights higher than 1 and would be returned first in a descending sort.","id":140},
{"explanation":"The clause \"WHERE my_data IN ('my_data1', 'my_data2', '%data3')\" is not a LIKE statement. It is equivalent to (my_data = 'my_data1' OR my_data  = 'my_data2' OR my_data = '%data3'). \n\n'my_data3' = '%data3' evaluates to FALSE. 'my_data3' LIKE '%data3'  would evaluate to TRUE, but that is not in the WHERE clause.\n\nTherefore, the select statement returns two rows: 'my_data1' and 'my_data2'.","id":141},
{"explanation":"This question concerns the behavior of NULL values. \n\nWhen the SELECT statement executes, my_table will have the following entries: ['my_data1', NULL, 'my_data3'].\n\nFor a record to pass the WHERE clause in the SELECT statement, it must evaluate to true either in my_data = NULL or my_data = 'my_data3'. Obviously 'my_data1' doesn't fit either of these, so it is excluded. \n\nThe main point of this question is that NULL = NULL does NOT evaluate to TRUE. It evaluates to UNKNOWN. So the NULL entry in my_table does not pass the WHERE clause. \n\nWhen 'my_data3' is passed in, the boolean logic is calculated as such:\n\n('my_data3' = NULL OR 'my_data3' = 'my_data3')\n\nwhich becomes\n\n(UNKNOWN OR TRUE).\n\nThe Oracle truth tables calculate (UNKNOWN OR TRUE) as TRUE, so 'my_data3' passes the WHERE condition and is the only value to do so.","id":142},
{"explanation":"For anything to be returned by the SELECT query, the WHERE clause must return true. Remember that anything = NULL always returns UNKNOWN (including NULL = NULL), so nothing will ever be returned by this select query.","id":143},
{"explanation":"Firstly, Oracle evaluates empty strings and NULL values interchangeably, so for all purposes the first INSERT places a NULL record in my_table.\n\nThis also means that the third INSERT statement evaluates ('my_data3' || NULL) as ('my_data3' || ''), which in turn evaluates to 'my_data3'\n\nSo after the INSERT statements, there are three values in my_table: [NULL, NULL, 'my_data3'].\n\n(NULL IS NULL) evaluates to TRUE and ('my_data3' IS NULL) evaluates to FALSE, so the first two record are returned.","id":144},
{"explanation":"Firstly, Oracle evaluates empty strings and NULL values interchangeably, so for all purposes the first INSERT places a NULL record in my_table.\n\nThis also means that the third INSERT statement evaluates ('my_data3' || NULL) as ('my_data3' || ''), which in turn evaluates to 'my_data3'\n\nSo after the INSERT statements, there are three values in my_table: [NULL, NULL, 'my_data3'].\n\n(NULL IS NULL) evaluates to TRUE and ('my_data3' IS NULL) evaluates to FALSE, so the first two record are returned.","id":145},
{"explanation":"Firstly, Oracle evaluates empty strings and NULL values interchangeably, so for all purposes the first INSERT places a NULL record in my_table.\n\nThis also means that the third INSERT statement evaluates ('my_data3' || NULL) as ('my_data3' || ''), which in turn evaluates to 'my_data3'\n\nSo after the INSERT statements, there are three values in my_table: [NULL, NULL, 'my_data3'].\n\nFor a record to pass the WHERE clause it must return TRUE. (NULL <> NULL) evaluates to UNKNOWN and ('my_data3' <> NULL) also evaluates to UNKNOWN. No records evaluate to TRUE and thus no records are returned.","id":146},
{"explanation":"Firstly, Oracle evaluates empty strings and NULL values interchangeably, so for all purposes the first INSERT places a NULL record in my_table.\n\nThis also means that the third INSERT statement evaluates ('my_data3' || NULL) as ('my_data3' || ''), which in turn evaluates to 'my_data3'\n\nSo after the INSERT statements, there are three values in my_table: [NULL, NULL, 'my_data3'].\n\nFor a record to pass the WHERE clause it must return TRUE. (NULL IS NOT NULL) evaluates to FALSE and ('my_data3' IS NOT NULL) evaluates to TRUE. One record evaluates to TRUE in the WHERE clause so only one record is returned.","id":147},
{"explanation":"DEFINE specifies a substitution variable and assigns a CHAR value to it, OR\nlists the value and variable type of a single variable or all variables.\n\nSHOW Shows the value of a SQLcl system variable, or the current\nSQLcl environment.\n\nSHOW &, SHOW DEFINE and EXPLAIN & are all invalid SQL commands.","id":148},
{"explanation":"ANY string in a query can be replaced by a defined substitution variable, including keywords, expressions, parameters and even database object names.","id":149},
{"explanation":"UNDEFINE deletes one or more substitution variables that you defined either explicitly (with the DEFINE command), or implicitly (with a START command argument).\n\nSET DEFINE OFF turns off substitution variable functionality but does not delete substitution variables.\n\nDELETE is used to remove rows from a table.\n\nREMOVE is not a real SQL command.\n\nDEREFERENCE is not a real SQL command.","id":150},
{"explanation":"It is perfectly valid to ORDER BY columns not in the select list.\n\nORDER BY clauses always come at the end of a SELECT statement.\n\nORDER BY clauses are always optional.\n\nNULL values are always given the highest sorting weight, so they are sorted last in an ascending sort but first in a descending sort.\n\nORDER BY does not change any data. It only changes the order by which rows are returned in a SELECT statement.","id":151},
{"explanation":"NULL values are always weighted higher than any other values in the column. my_data is sorted DESC, so the highest weighted values are returned first. Therefore, NULL is returned first.","id":152},
{"explanation":"my_data is sorted ASC, so the lowest weighted values are returned first. \n\nNULL values are always weighted higher than any other values in the column, so we know that they will be returned last.\n\n'my_data1' and 'my_data2' are identical strings until the last character, so the sorting comes down to that last character. '1' comes before '2' in ASCII, so it is weighted lower. Therefore 'my_data1' is weighted the lowest and returned first in an ascending sort.","id":153},
{"explanation":"When ASC or DESC are not specified for a column in an ORDER BY clause, thar column is defaulted as sorting to ASC. This means that my_data is sorted ASC, so the lowest weighted values are returned first. \n\nNULL values are always weighted higher than any other values in the column, so we know that they will be returned last.\n\n'my_data1' and 'my_data2' are identical strings until the last character, so the sorting comes down to that last character. '1' comes before '2' in ASCII, so it is weighted lower. Therefore 'my_data1' is weighted the lowest and returned first in an ascending sort.","id":154},
{"explanation":"After the INSERT statements, my_table has the following data in it:\n\n[1, 2, 1]\n[2, 1, 2]\n\nWhen ASC or DESC are not specified for a column in an ORDER BY clause, that column is defaulted as sorting to ASC. Therefore both my_data1 and my_data2 are being sorted ASC.\n\nTake the full dataset, and then order by my_data1 ASC:\n\nRow 1: [1, 2, 1]\nRow 2: [2, 1, 2]\n\nThen, group the above sorted dataset by unique values of my_data1 and sort those subsets by my_data2 ASC:\n\nGroup 1 (my_data1 = 1):\nRow 1: [1, 2, 1]\nGroup 2 (my_data1 = 2):\nRow 1: [2, 1, 2]\n\nBecause there are only two rows, this is a trivial example and the row order remains unchanged from the my_data2 sorting. So the result is:\n\nRow 1: [1, 2, 1]\nRow 2: [2, 1, 2]\n\nThe id value of Row 1 is 1, so our result is 1.","id":155},
{"explanation":"After the INSERT statements, my_table has the following data in it:\n\n[1, 2, 1]\n[2, 1, 2]\n\nWhen ASC or DESC are not specified for a column in an ORDER BY clause, that column is defaulted as sorting to ASC. Therefore both my_data1 and my_data2 are being sorted ASC.\n\nTake the full dataset, and then order by my_data2 ASC:\n\nRow 1: [2, 1, 2]\nRow 2: [1, 2, 1]\n\nThen, group the above sorted dataset by unique values of my_data2 and sort those subsets by my_data1 ASC:\n\nGroup 1 (my_data2 = 1):\nRow 1: [2, 1, 2]\nGroup 2 (my_data2 = 2):\nRow 1: [1, 2, 1]\n\nBecause there are only two rows, this is a trivial example and the row order remains unchanged from the my_data1 sorting. So the result is:\n\nRow 1: [1, 2, 1]\nRow 2: [2, 1, 2]\n\nThe id value of Row 1 is 2, so our result is 2.","id":156},
{"explanation":"After the INSERT statements, my_table has the following data in it:\n\n[1, 2, 1]\n[2, 1, 2]\n\nWhen ASC or DESC are not specified for a column in an ORDER BY clause, that column is defaulted as sorting to ASC. Therefore both my_data1 is being sorted as ASC.\n\nTake the full dataset, and then order by my_data2 DESC:\n\nRow 1: [1, 2, 1]\nRow 2: [2, 1, 2]\n\nThen, group the above sorted dataset by unique values of my_data2 and sort those subsets by my_data1 ASC:\n\nGroup 1 (my_data2 = 2):\nRow 1: [1, 2, 1]\nGroup 2 (my_data2 = 1):\nRow 1: [2, 1, 2]\n\nBecause there are only two rows, this is a trivial example and the row order remains unchanged from the my_data1 sorting. So the result is:\n\nRow 1: [1, 2, 1]\nRow 2: [2, 1, 2]\n\nThe id value of Row 1 is 1, so our result is 1.","id":157},
{"explanation":"After the INSERT statements, my_table has the following data in it:\n\n[1, 2, 1]\n[2, 1, 2]\n\n\nTake the full dataset, and then order by my_data2 ASC:\n\nRow 1: [2, 1, 2]\nRow 2: [1, 2, 1]\n\nThen, group the above sorted dataset by unique values of my_data2 and sort those subsets by my_data1 DESC:\n\nGroup 1 (my_data2 = 1):\nRow 1: [1, 2, 1]\nGroup 2 (my_data2 = 2):\nRow 1: [2, 1, 2]\n\nBecause there are only two rows, this is a trivial example and the row order remains unchanged from the my_data1 sorting. So the result is:\n\nRow 1: [1, 2, 1]\nRow 2: [2, 1, 2]\n\nThe id value of Row 1 is 2, so our result is 2.","id":158},

//more order by questions with 3-5 rows
{"explanation":"When ASC or DESC are not specified for a column in an ORDER BY clause, that column is defaulted as sorting to ASC. So, we are sorting by my_data1 / my_data2 ASC.\n\nAfter the INSERT statements, my_table has the following data in it:\n\n[1, 2, 1]\n[2, 1, 2]\n\nThe my_data1 / my_data2 values for these are as follows:\n\n[1, 2, 1] -> 1/2 = 0.5\n[2, 1, 2] -> 2/1 = 2\n\n0.5 is weighted less than 2, so it is returned first in an ascending sort. So the ranking is:\n\nRow 1: [1, 2, 1]\nRow 2: [2, 1, 2]\n\nThe id value of Row 1 is 1, so our result is 1.","id":159},
{"explanation":"When using the ORDER BY <number> syntax, the number corresponds with the column in the select list at that number's index. Because our example uses ORDER BY 1, we sort by the id column.\n\nWhen ASC or DESC are not specified for a column in an ORDER BY clause, that column is defaulted as sorting to ASC. So, we are sorting by id ASC.\n\nAfter the INSERT statements, my_table has the following data in it:\n\n[1, 2, 1]\n[2, 1, 2]\n\nSorting by id ASC yields:\n\nRow 1: [1, 2, 1]\nRow 2: [2, 1, 2]\n\nThe id value of Row 1 is 1, so our result is 1.","id":160},
{"explanation":"When using the ORDER BY <number> syntax, the number corresponds with the column in the select list at that number's index. Because our example uses ORDER BY 2, but we only have one column in the SELECT list, an error is thrown.","id":161},
{"explanation":"After the INSERT statements, my_table has the following data in it:\n\n[1, 2, 1]\n[2, 1, 2]\n\nWhen ASC or DESC are not specified for a column in an ORDER BY clause, that column is defaulted as sorting to ASC. So, we are sorting by my_data2 - ROWNUM ASC.\n\nBecause [1, 2, 1] was inserted first, it has ROWNUM = 1. [2, 1, 2] has ROWNUM = 2 because it was inserted second.\n\nThus, the my_data2 - ROWNUM evaluations of the rows are as follows:\n\n[1, 2, 1] -> 2 - 1 = 1\n[2, 1, 2] -> 1 - 2 = -1\n\n-1 is weighted lower than 1, so that row is returned first in an ascending sort.\n\nRow 1: [2, 1, 2]\nRow 2: [1, 2, 1]\n\nThe id value of Row 1 is 2, so our result is 2.","id":162},
{"explanation":"Execution fails because we have given the same alias \"my_column\" to 2 different columns in the select list. An \"ambiguous column naming in select list\" exception is thrown.","id":163},
{"explanation":"We are giving id the quoted identifier \"my column\", which is valid.\n\nWhen ASC or DESC are not specified for a column in an ORDER BY clause, that column is defaulted as sorting to ASC. So, we are sorting by id ASC.\n\nAfter the INSERT statements, my_table has the following data in it:\n\n[1, 2, 1]\n[2, 1, 2]\n\nBecause this is an ascending sort, the row with the smallest id value will be returned first. So we have:\n\nRow 1: [1, 2, 1]\nRow 2: [2, 1, 2]\n\nThe id value of Row 1 is 1, so our result is 1.","id":164},


//ambiguity in question 165: add create table statement to explicitly show that there is no my_column column in my_table
{"explanation":"Execution fails because there is no column in my_table named my_column.","id":165},
{"explanation":"The <> relational operator is equivalent to a \"not equals\" condition.\n\nAfter the INSERT statements, my_table has the following data in it:\n\n[1, 2, 1]\n[2, 1, 2]\n\nOne row has my_data1 = 1 and one has my_data1 = 2, so only one record is returned by the select query.","id":166},
{"explanation":"After the INSERT statements, my_table has the following data in it:\n\n[1, 2, 1]\n[2, 1, 2]\n\n[1, 2, 1] was inserted first, so its ROWNUM = 1. [2, 1, 2] was inserted second, so its ROWNUM = 2. \n\nBoth records have ROWNUM = my_data1, so both are returned.","id":167},
{"explanation":"After the INSERT statements, my_table has the following data in it:\n\n[1, 2, 1]\n[2, 1, 2]\n\nIn both rows, my_data1 = id. So there is no case where my_data2 > id, and thus no rows pass the WHERE condition.","id":168},
{"explanation":"After the INSERT statements, my_table has the following data in it:\n\n[30-DEC-2017, 1]\n[30-DEC-2016, 2]\n\n\nWhen ASC or DESC are not specified for a column in an ORDER BY clause, that column is defaulted as sorting to ASC. So, we are sorting by my_date ASC.\n\nDate values are sorted with earlier dates being weighted lower and later dates being weighted higher. 30-DEC-2016 is an earlier date than 30-DEC-2017, so it is ranked lower and thus returned first in an ascending sort.\n\nSo the result is:\n\nRow 1: [30-DEC-2016, 2]\nRow 2: [30-DEC-2017, 1]\n\n\nThe id value of Row 1 is 2, so our result is 2.\n","id":169},
{"explanation":"After the INSERT statements, my_table has the following data in it:\n\n['DATA', 1]\n['data', 2]\n\nCharacter equality operators are case sensitive so 'data' = 'DATA' returns FALSE. 'DATA' = 'DATA' returns true, so 1 record is returned.","id":170},
{"explanation":"After the INSERT statements, my_table has the following data in it:\n\n['DATA', 1]\n['data', 2]\n\nThe underscore '_' character in a pattern matching LIKE statement maps to any single character. 'DATA' matches this pattern so it is returned. 'data' matches to the character length but non-wildcard characters in pattern matching such as the 'A' in '_A__', are still case sensitive. So 'data' LIKE '_A__' evaluates to FALSE.","id":171},
{"explanation":"After the INSERT statements, my_table has the following data in it:\n\n['DATA', 1]\n['data', 2]\n\nThe percent '%' character in a pattern matching LIKE statement maps to any number of any characters. However, any non-wildcard characters, such as the 'a' in '%a%', are still case-sensitive.\n\nSo 'data' LIKE '%a%' evaluates to TRUE, but 'DATA' LIKE '%a%' evaluates to FALSE. So only one record is returned.","id":172},
{"explanation":"\"my_data LIKE '_A_'\" would not work because the underscore '_' character in a pattern matching LIKE statement maps to any single character. 'DATA' has a length of 4 characters, but to match to that pattern it would need to have a length of 3 characters.\n\n\"1 = 1\" would work because it always evaluates to TRUE.\n\n\"my_data LIKE '%T_'\" would work because it requires its input only to have 1 character after the 'T', and any number of characters before it, which 'DATA' does. \n\n\"LOWER(my_data) LIKE '%a%'\" works because 'DATA' is transformed into 'data' prior to the LIKE statement, and thus matches the pattern.\n\n\"my_data = 'DA' || 'TA'\" works because the concatenation resolves before the equality operation, making the evaluation result in TRUE.","id":173},
{"explanation":"\"my_data LIKE 'DATA%'\" works because the percent '%' character in a pattern matching LIKE statement maps to any number of any characters, which includes 0 additional characters.\n\n\"my_data LIKE 'DATA'\" works because, even though there are no wildcard characters, the evaluation still matches each of the hardcoded literal characters.\n\n\"my_data LIKE 'D%A_'\" does not work because it requires exactly one character after the 'A', which is not the case for either of the 'A' characters present in 'DATA'.\n\n\"my_data IS 'DATA'\" is invalid syntax.\n\n\"'%A%' LIKE my_data\" does not work. Wildcard characters must only be placed to the right of the LIKE keyword.","id":174},
{"explanation":"After the INSERT statements, my_table has the following data in it:\n\n[1, 2, 1]\n[2, 1, 2]\n[0, 1, 3]\n\nThe rows where (my_data1 > 0) evaluates to TRUE are:\n\n[1, 2, 1]\n[2, 1, 2]\n\nAnd of those, the row where (my_data2 < 2) evaluates to TRUE is:\n\n[2, 1, 2]\n\n\nThe id value of this row is 2, so our result is 2.\n","id":175},
{"explanation":"After the INSERT statements, my_table has the following data in it:\n\n[0, 2, 1]\n[2, 1, 2]\n[0, 1, 3]\n\nRemember that Oracle's order of operations evaluates NOT before AND, so the WHERE clause can be grouped as:\n\nWHERE (NOT my_data1 > 0) AND (my_data2 < 2)\n\nThe rows where (NOT my_data1 > 0) evaluates to TRUE are:\n\n[0, 1, 3]\n[0, 2, 1]\n\nAnd of those, the row where (my_data2 < 2) evaluates to TRUE is:\n\n[0, 1, 3]\n\nThe id value of this row is 3, so our result is 3.\n","id":176},
{"explanation":"After the INSERT statements, my_table has the following data in it:\n\nRow 1: [0, 1]\nRow 2: [2, 2]\n\nWe want the expressions for which only Row 2 matches.\n\nThe != expression returns true if the operators are not equal. \"my_data != 0\" works because Row 2's my_data column evaluates in the WHERE clause as (2 != 1) = TRUE.\n\nThe <> expression returns true if the operators are not equal and is identical to !=. \"my_data <> 0\" works because Row 2's my_data column evaluates in the WHERE clause as (2 <> 1) = TRUE.\n\n\"NOT my_data = 0\" works because it is equivalent to the above two expressions.\n\n\"my_data IS NOT 0\" is incorrect syntax. IS NOT can only be used as IS NOT NULL.\n\n\n\"my_data NOT = 0\" is incorrect syntax. NOT must be placed to the left of the column name.\n","id":177},
{"explanation":"After the INSERT statements, my_table has the following data in it:\n\n[0, 1, 1]\n[0, 2, 2]\n[1, 1, 3]\n[1, 2, 4]\n\n\nRemember that the Oracle order of operations evaluates AND before OR, so the WHERE clause condition can be grouped as:\n\nWHERE (my_data1 = 0) OR (my_data1 = 1 AND my_data2 = 2)\n\nThe rows for which (my_data1 = 0) evaluates to true are:\n\n[0, 1, 1]\n[0, 2, 2]\n\n\nThe row for which (my_data1 = 1 AND my_data2 = 2) evaluates to true is:\n\n[1, 2, 4]\n\nSo those rows which satisfy (my_data1 = 0) OR (my_data1 = 1 AND my_data2 = 2) is simply the union of those two rowsets:\n\n[0, 1, 1]\n[0, 2, 2]\n[1, 2, 4]\n\nTherefore 3 rows are returned.","id":178},
{"explanation":"After the INSERT statements, my_table has the following data in it:\n\n[0, 1, 1]\n[0, 2, 2]\n[1, 1, 3]\n[1, 2, 4]\n\n\nEven though the Oracle order of operations evaluates AND before OR, the grouping of expressions by parenthesis overrides that ordering.\n\nThe rows for which  (my_data1 = 0 OR my_data1 = 1)  evaluates to true are:\n\n[0, 1, 1]\n[0, 2, 2]\n[1, 1, 3]\n[1, 2, 4]\n\n\nThe rows for which (my_data2 = 2) evaluates to true are:\n\n[0, 2, 2]\n[1, 2, 4]\n\nSo those rows which satisfy  (my_data1 = 0 OR my_data1 = 1) AND (my_data2 = 2) is simply the intersection of those two rowsets:\n\n[0, 2, 2]\n[1, 2, 4]\n\nTherefore 2 rows are returned.","id":179},
{"explanation":"After the INSERT statements, my_table has the following data in it:\n\n[0]\n[10]\n\nWe want a WHERE expression which evaluates to true for both 0 and 10.\n\n\"my_data NOT IN (3)\" works because (NOT 0 = 3) AND (NOT 10 = 3) evaluates to TRUE.\n\n\"my_data BETWEEN 0 AND 10\" works because the BETWEEN operator reduces to (my_data >= 0 AND my_data <= 10), which evaluates to TRUE for both 0 and 10.\n\n\"my_data IN (0, 10)\" works because  IN reduces to ((my_data = 0) OR (my_data = 10)), which evaluates TRUE for both 0 and 10.\n\n\"my_data IN (0, '1' || '0')\" works because || (concatenation) has a higher priority than = (equality comparison), and because Oracle will implicitly convert '10' to a NUMBER. So this one is equivalent to \"my_data IN (0, 10)\".\n\n\n\"my_data BETWEEN 10 AND 0\" does not work because the expression reduces to (my_data >= 10 AND my_data <= 0), which is never evaluated to TRUE. It is important to always place the smaller number first in a BETWEEN statement.\n\n","id":180},
{"explanation":"\"my_data BETWEEN 1 AND 0\" always returns 0 rows because the expression reduces to (my_data >= 1 AND my_data <= 0), which is never evaluated to TRUE. It is important to always place the smaller number first in a BETWEEN statement.\n\n","id":181},
{"explanation":"For a row to be accepted by a WHERE clause, the WHERE expression must evaluate to TRUE.\n\n<anything> = NULL always evaluates to UNKNOWN, so no rows will ever be returned by this select statement.","id":182},
{"explanation":"After the INSERT statements, my_table has the following data in it:\n\n[0]\n[NULL]\n\nFor a row to be accepted by a WHERE clause, the WHERE expression must evaluate to TRUE.\n\n0 IS NULL evaluates to FALSE.\nNULL IS NULL evaluates to TRUE.\n\nSo one record, the NULL record, is returned.\n","id":183},
{"explanation":"For a row to be accepted by a WHERE clause, the WHERE expression must evaluate to TRUE. \n\n<anything> != NULL always evaluates to UNKNOWN, so this select statement will never return anything.","id":184},
{"explanation":"After the INSERT statements, my_table has the following data in it:\n\n[0]\n[NULL]\n\nFor a row to be accepted by a WHERE clause, the WHERE expression must evaluate to TRUE.\n\n0 IS NOT NULL evaluates to TRUE.\nNULL IS NOT NULL evaluates to FALSE.\n\nSo one record, the 0 record, is returned by the query.","id":185},
{"explanation":"After the INSERT statements, my_table has the following data in it:\n\n[0]\n[NULL]\n\nFor a row to be accepted by a WHERE clause, the WHERE expression must evaluate to TRUE.\n\nmy_data NOT IN (0) reduces to the logical expression (my_data != 0).\n\n0 != 0 evaluates to FALSE.\nNULL != 0 evaluates to UNKNOWN.\n\nBecause no records evaluated to TRUE, no records are returned.","id":186},
{"explanation":"After the INSERT statements, my_table has the following data in it:\n\n[1]\n[NULL]\n\n&myVar substitutes for 1 due to the DEFINE statement at the top of the code. So the WHERE clause becomes (my_data = 1), which is matched with one record in my_table.","id":187},
{"explanation":"First, the DEFINE statement sets myVar = \"NOT\". However, myVar is removed due to the UNDEFINE statement.\n\nUNDEFINED variables always equate to an empty string, so the WHERE clause becomes :\n\nWHERE my_data = 1;\n\nWhich is matched to by the row inserted by the INSERT statement.","id":188},
{"explanation":"The SHOW command displays the value of a SQLcl system variable, or the current\nSQLcl environment. \n\nThe DEFINE command specifies a substitution variable and assigns a CHAR value to it, or\nlists the value and variable type of a single variable or all variables.\n\nThe DESCRIBE command lists the column definitions for a table, view, or synonym, or the specifications for a function or procedure.\n\nThere are no such SQL commands as VERIFY or DISPLAY.","id":189}.
{"explanation":"If you SET VERIFY, PL/SQL will print a message every time a DEFINED variable is substituted. \n\nDEFINE, ACCEPT, SHOW and PROMPT are all commands, not system variables.","id":190}

//spelling error on line 191
{"explanation":"PROMPT is a SQL command which sends the specified message or a blank line to the user's screen.\n\nVERIFY is a system variable which toggles whether or not PL/SQL will print a message every time a DEFINED variable is substituted. \n\nDEFINE specifies a substitution variable and assigns a CHAR value to it, or lists the value and variable type of a single variable or all variables.\n\nSHOW diaplays the value of a SQLcl system variable, or the current\nSQLcl environment. \n\nACCEPT reads a line of input and stores it in a given substitution variable.","id":191},
{"explanation":"ACCEPT reads a line of input and stores it in a given substitution variable.\n\nPROMPT is a SQL command which sends the specified message or a blank line to the user's screen.\n\nVERIFY is a system variable which toggles whether or not PL/SQL will print a message every time a DEFINED variable is substituted. \n\nDEFINE specifies a substitution variable and assigns a CHAR value to it, or lists the value and variable type of a single variable or all variables.\n\nSHOW diaplays the value of a SQLcl system variable, or the current\nSQLcl environment. ","id":192},




