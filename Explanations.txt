{"explanation":"Data manipulation language (DML) statements access and manipulate data in existing schema objects. Because SELECT is used to access data in a table or view, it is considered a DML command.","id":0},
{"explanation":"Data manipulation language (DML) statements access and manipulate data in existing schema objects. Because INSERT is used to add data to a table, it is considered a DML command.","id":1},
{"explanation":"Data manipulation language (DML) statements access and manipulate data in existing schema objects. Because UPDATE allows you to change existing data in a table, it is a DML statement.","id":2},
{"explanation":"Data manipulation language (DML) statements access and manipulate data in existing schema objects. Because DELETE removes data from a table, it is a DML statement.","id":3},
{"explanation":"Data manipulation language (DML) statements access and manipulate data in existing schema objects. Because MERGE conditionally deletes, inserts or modifies data in a table, it is considered a DML statement.","id":4},
{"explanation":"Data definition language (DDL) statements let you manipulate database objects or privileges.  Because CREATE instantiates a new database object, it is a DDL command.","id":5},
{"explanation":"Data definition language (DDL) statements let you manipulate database objects or privileges.  Because ALTER allows you to change the internal attributes of a database object, it is considered a DDL command.","id":6},
{"explanation":"Data definition language (DDL) statements let you manipulate database objects or privileges.  Because DROP removes an object from the database, it is a DDL command.","id":7},
{"explanation":"Data definition language (DDL) statements let you manipulate database objects or privileges. Because RENAME changes the name of a database object, it is a DDL command.","id":8},
{"explanation":"This one is tricky. Although TRUNCATE is used to remove data from a table, it does so by changing internal attributes of the table object, therefore it is a DDL command. Oracle explicitly classifies TRUNCATE as a DDL command.","id":9},
{"explanation":"Data definition language (DDL) statements let you manipulate database objects or privileges. Because GRANT is used to bestow privileges, it is a DDL command.","id":10}
{"explanation":"Data definition language (DDL) statements let you manipulate database objects or privileges. Because REVOKE is used to remove privileges, it is a DDL command.","id":11},
{"explanation":"Data definition language (DDL) statements let you manipulate database objects or privileges. Because FLASHBACK is used to revert a database object to a previous version of itself, it is a DDL statement.","id":12},
{"explanation":"Data definition language (DDL) statements let you manipulate database objects or privileges. Because PURGE is used to permanently remove an object from the database, it is a DDL command.","id":13},
{"explanation":"The scope of data definition language (DDL) statements includes adding comments to the data dictionary, so COMMENT is a DDL command.","id":14},
{"explanation":"Transaction control (TCL) statements manage changes made by DML statements. Because COMMIT is used to save the changes made by a set of DML statements, it is a TCL command.","id":15},
{"explanation":"Transaction control (TCL) statements manage changes made by DML statements. Because ROLLBACK is used to revert changes made by a set of DML commands, it is a TCL command.","id":16},
{"explanation":"CREATE is used to instantiate a new database object. ALTER is used to manipulate a database object. SELECT is used to access data in a table or view. GRANT is used to bestow a privilege. UPDATE is used to modify existing data in a table.","id":17},
{"explanation":"ALTER is used to manipulate a database object. CREATE is used to instantiate a new database object. SELECT is used to access data in a table or view. GRANT is used to bestow a privilege. UPDATE is used to modify existing data in a table.","id":18},
{"explanation":"DROP is used to remove an object from the database. ROLLBACK is used to revert changes made by a set of DML statements. DELETE is used to remove rows from a table. PURGE is used to permanently drop a database object. REVOKE is used to take a privileges away. ALTER is used to manipulate a database object.","id":19},
{"explanation":"CREATE is used to instantiate a new database object. ALTER is used to manipulate a database object. SELECT is used to access data in a table or view. GRANT is used to bestow a privilege. UPDATE is used to modify existing data in a table.","id":20},
{"explanation":"ALTER is used to manipulate a database object. CREATE is used to instantiate a new database object. SELECT is used to access data in a table or view. GRANT is used to bestow a privilege. UPDATE is used to modify existing data in a table.","id":21},
{"explanation":"DROP is used to remove an object from the database. ROLLBACK is used to revert changes made by a set of DML statements. DELETE is used to remove rows from a table. PURGE is used to permanently drop a database object. REVOKE is used to take a privileges away. ALTER is used to manipulate a database object.","id":22},
{"explanation":"RENAME is used to change the name of a database object. COMMENT is used to add an annotation to the data dictionary. ALTER is used to modify a database object. UPDATE is used to modify existing data in a table. CREATE is used to instantiate a new database object.","id":23},
{"explanation":"TRUNCATE is used to immediately remove all records from a table, partition or subpartition by changing the internal object attributes. DROP is used to remove an object from the database. ROLLBACK is used to revert changes made by a set of DML statements. DELETE is used to remove rows from a table. PURGE is used to permanently drop a database object.","id":24},
{"explanation":"GRANT is used to bestow a privilege. ALTER is used to modify a database object. CREATE is used to instantiate a new database object. REVOKE is used to take a privileges away. SELECT is used to access data in a table or view.","id":25},
{"explanation":"REVOKE is used to take a privileges away. TRUNCATE is used to immediately remove all records from a table, partition or subpartition by changing the internal object attributes. DROP is used to remove an object from the database. DELETE is used to remove rows from a table. REMOVE is not a real SQL command.","id":26},
{"explanation":"FLASHBACK is used to revert a database object to a previous version of itself. ROLLBACK is used to revert changes made by a set of DML statements. RESTORE is not a real SQL command. UPDATE is used to modify existing data in a table. REVERT is not a real SQL command.","id":27},
{"explanation":"PURGE is used to permanently drop a database object and remove it from the recycle bin. TRUNCATE is used to immediately remove all records from a table, partition or subpartition by changing the internal object attributes. COMMIT is used to save changes made by a set of DML statements. DROP is used to remove an object from the database. EMPTY is not a real SQL command.","id":28},
{"explanation":"COMMENT is used to add an annotation to the data dictionary. UPDATE is used to modify existing data in a table. ALTER is used to modify a database object. ANNOTATE is not a real SQL command. REFERENCE is not a real SQL command.","id":29},
{"explanation":"SELECT is used to access data in a table or view. SHOW is not a real SQL command. DATA is not a real SQL command. DISPLAY is not a real SQL command. INSERT is used to insert rows into a table.","id":30},
{"explanation":"INSERT is used to add new rows to a table. UPDATE is used to modify existing data in a table. ALERT is not a real SQL command. ROW is not a real SQL command. CREATE is used to instantiate a new database object. ","id":31},
{"explanation":"UPDATE is used to modify existing data in a table. INSERT is used to insert rows into a table. MODIFY is not a real SQL command. ALTER is used to modify a database object. RENAME is used to change the name of a database object.","id":32},
{"explanation":"DELETE is used to remove rows from a table. DROP is used to remove an object from the database. TRUNCATE is used to immediately remove all records from a table, partition or subpartition by changing the internal object attributes. PURGE is used to permanently drop a database object and remove it from the recycle bin. REMOVE is not a real SQL command.","id":33},
{"explanation":"MERGE selects rows from one or more source to conditionally insert, update or delete rows in a table. INSERT is used to insert rows into a table. UPDATE is used to modify existing data in a table. DELETE is used to remove rows from a table. ALTER is used to modify a database object.","id":34},
{"explanation":"COMMIT is used to save changes made by a set of DML statements. SAVE is not a real SQL command. ROLLBACK is used to revert changes made by a set of DML statements. SAVEPOINT is used to mark a specific instance in time or execution flow. EXECUTE IMMEDIATE is used to execute a string as if it were a SQL statement.","id":35},
{"explanation":"ROLLBACK is used to revert changes made by a set of DML statements. REVOKE is used to take a privileges away. RESET is not a real SQL command. DELETE is used to remove rows from a table. FLASHBACK is used to revert a database object to a previous version of itself.","id":36},
{"explanation":"SAVEPOINT is used to mark a specific instance in time or execution flow to which a future ROLLBACK can revert. COMMIT is used to save changes made by a set of DML statements. TRANSACTION is not a real SQL command. ROLLBACK is used to revert changes made by a set of DML statements. FLASHBACK is used to revert a database object to a previous version of itself.","id":37},
{"explanation":"A CONSTRAINT can be owned by a user so it is a schema object.","id":38},
{"explanation":"A SEQUENCE can be owned by a user so it is a schema object.","id":39},
{"explanation":"An INDEX can be owned by a user so it is a schema object.","id":40},
{"explanation":"A PRIVATE SYNONYM can be owned by a user so it is a schema object.","id":41},
{"explanation":"A TABLE can be owned by a user so it is a schema object.","id":42},
{"explanation":"A VIEW can be owned by a user so it is a schema object.","id":43},
{"explanation":"A ROLE cannot be owned by a user so it is non-schema object.","id":44},
{"explanation":"A ROLE cannot be owned by a user so it is non-schema object.","id":44},
{"explanation":"A USER cannot be owned by a user so it is non-schema object.","id":46},
{"explanation":"Official Oracle docs: \"A schema is a collection of database objects. A schema is owned by a database user and has the same name as that user. Schema objects are logical structures created by users. Objects such as tables or indexes hold data, or can consist of a definition only, such as a view or synonym.\" ","id":47},
{"explanation":"Official Oracle docs: \"Nonschema objects: Other types of objects are also stored in the database and can be created and manipulated with SQL but are not contained in a schema:\" ","id":48},
{"explanation":"PRIVATE SYNONYMs are schema objects that can be owned by users. USER objects themselves are not contained in any schema and are therefore nonschema objects. Because a USER object is nonschema, it cannot be owned by a USER object, including itself.","id":49},
{"explanation":"Official Oracle docs: \"The PUBLIC role is a special role that every database user account automatically has when the account is created. By default, it has no privileges granted to it, but it does have numerous grants, mostly to Java objects. You cannot drop the PUBLIC role, and a manual grant or revoke of this role has no meaning, because the user account will always assume this role. Because all database user accounts assume the PUBLIC role, it does not appear in the DBA_ROLES and SESSION_ROLES data dictionary views.\"","id":50},
{"explanation":"Oracle requires all unquoted object names to start with a letter, but they may also contain '$', '_' or '#'. All database objects must have a name, and in the rare cases where objects are created without a name the system generates a generic object name for them. Unquoted object names may not contain spaces (although quoted object names can). Unquoted object names are not case sensitive (although quoted object names are).","id":51}
{"explanation":"Quoted object names are case sensitive are case sensitive (although unquoted object names are not), Quoted object names must be references with their quotation marks -- a table with a quoted name \"MY_TABLE\" cannot be referenced by the unquoted string MY_TABLE. Quoted object names can contain spaces -- \"my table\" is a valid name. Quoted object names CAN contain reserved words and may start with any character.","id":52},
{"explanation":"A NAMESPACE is a logical boundary within the database which requires encompassing objects to have unique names. A CLUSTER is a schema object that contains data from one or more tables (and is not on the 1Z0-071 exam). A SCHEMA is a collection of logical structures of data, or schema objects. A DATABASE is a collection of data treated as a unit. A USER is a type of schema object.","id":53},
{"explanation":"Users and Roles are in the same non-schema namespace. Public synonyms are in their own non-schema namespace. Tables, Indexes and Constraints are all in separate schema namespaces.","id":54},
{"explanation":"Private Synonyms, Views, Sequences and Tables are all in the same schema namespace. Public Synonyms are in their own non-schema namespace.","id":55},
{"explanation":"Schema objects are in schema namespaces which are contained inside of schemas -- meaning, different schemas have different namespaces. Every USER object in the database must have a unique name because USER objects are in a non-schema namespace (with ROLEs). If they were in a schema namespace, you would be able to have two users with the same name as long as they were in different schemas. Only objects in the same namespace are prohibited from having the same name, so objects in different namespaces can clearly have the same name. INDEX and CONSTRAINT objects are in different namespaces (a user can own a PRIMARY KEY and a UNIQUE INDEX with the same name).","id":56},
{"explanation":"One NOT NULL constraint and one PRIMARY KEY constraint are created. It is important to note that PRIMARY KEY counts as a single constraint and not one UNIQUE INDEX plus one NOT NULL. Also, DEFAULT is not counted as a constraint.","id":57},
{"explanation":"DESC is used to return formatted details about a given table. SHOW is not a SQL command. EXPLAIN is not a SQL command. DETAILS is not a SQL command. HELP is not a SQL command.","id":58},
{"explanation":"The NUMBER data type has the optional parameters NUMBER(precision, scale). Precision is the total number of digits and Scale is the number of digits to the right of the decimal point that the number should be rounded to. When Precision is defined but Scale isn't, Scale = 0. You can specify a Scale with no Precision by using NUMBER(*, scale). When neither are defined, the number is taken as-is.\n\nIn this example, Precision = 2 and Scale = 0. So we are allowed 2 digits (5.67 becomes 5.6) but the number is rounded to 0 places after the decimal, making 5.6 round to 6 and giving us our answer.","id":59},
{"explanation":"The NUMBER data type has the optional parameters NUMBER(precision, scale). Precision is the total number of digits and Scale is the number of digits to the right of the decimal point that the number should be rounded to. When Precision is defined but Scale isn't, Scale = 0. You can specify a Scale with no Precision by using NUMBER(*, scale). When neither are defined, the number is taken as-is.\n\nBecause no Precision or Scale is defined, the number is stored as-is: 5.67.","id":60},
{"explanation":"The NUMBER data type has the optional parameters NUMBER(precision, scale). Precision is the total number of digits and Scale is the number of places to the right of the decimal point that the number should be rounded to. When Precision is defined but Scale isn't, Scale = 0. You can specify a Scale with no Precision by using NUMBER(*, scale). When neither are defined, the number is taken as-is.\n\nIn this example, our Precision = 5, so we are allowed to have 5 digits. However, our Scale = 2, so we round to two places to the right of the decimal, giving us our answer as 5.68.","id":61},
{"explanation":"The NUMBER data type has the optional parameters NUMBER(precision, scale). Precision is the total number of digits and Scale is the number of places to the right of the decimal point that the number should be rounded to. When Precision is defined but Scale isn't, Scale = 0. You can specify a Scale with no Precision by using NUMBER(*, scale). When neither are defined, the number is taken as-is.\n\nIn this example, our Precision = 4, so we are allowed to have 4 digits. However, our Scale = 1, so we round to 1 place after the decimal (5.67 rounds to 5.7).","id":62},
{"explanation":"Official Oracle docs: \"The DATE datatype stores point-in-time values (dates and times) in a table. The DATE datatype stores the year (including the century), the month, the day, the hours, the minutes, and the seconds (after midnight).\"","id":63},
{"explanation":"OBLOB does not exist. BLOB stands for Binary Large Object and stores any kind of data in binary format. CLOB stands for Character Large Object and stores large string data in the database character set format. NCLOB stands for National Character Set Large Object and stores large string data in the National Character Set format.","id":64},
{"explanation":"Official Oracle docs regarding BLOBs: \"Stores any kind of data in binary format. Typically used for multimedia data such as images, audio, and video.\"\n\nCLOB stands for Character Large Object and stores large string data in the database character set format. OBJECT is not a data type. IMAGE is not a data type. FILE is not a data type.","id":65},
{"explanation":"There is no such thing as a CREATE CONSTRAINT statement. ","id":66},
{"explanation":"There is no such thing as a CREATE CONSTRAINT statement. NOT NULL constraints cannot be added by the ALTER TABLE ADD CONSTRAINT syntax - They must use ALTER TABLE MODIFY <column>. NOT NULL constraints can only be added in a CREATE TABLE statement when they are inline with the respective columns (e.g. \"my_num NUMBER NOT NULL\") and they cannot be added out-of-line with their respective columns (where \"CONSTRAINT my_pk PRIMARY KEY (my_num)\" is valid to include in a CREATE TABLE statement to create a PRIMARY KEY, there is no such statement for NOT NULL constraints.)","id":67},
{"explanation":"A UNIQUE constraint ensures that a set of specified columns will never be repeated by two rows in the same table. A FOREIGN KEY constraint ensures that values in one table exist in another table. A NOT NULL constraint ensures that the column value is never NULL. A CHECK constraint ensures that they column value adheres to a defined custom logic. /*REF CONSTRAINT EXPLANATION*/","id":69},
{"explanation":"A PRIMARY KEY ensures that its column combinations are unique and that none of their values are NULL. \n\nA FOREIGN KEY constraint ensures that values in one table exist in another table. \n\nThere is no such thing as a LOCAL KEY constraint.\n\n/*REF CONSTRAINT EXPLANATION*/\n\nA CHECK constraint ensures that they column value adheres to a defined custom logic.","id":70},
{"explanation":"A FOREIGN KEY constraint ensures that values in one table exist in another table, thus preserving referential integrity.\n\nA NOT NULL constraint ensures that the column value is never NULL.\n\nA CHECK constraint ensures that they column value adheres to a defined custom logic.\n\nA UNIQUE constraint ensures that a set of specified columns will never be repeated by two rows in the same table.\n\nA PRIMARY KEY constraint ensures that a certain column combination is always unique and that none of its values are NULL.","id":71},
{"explanation":"Without an ON DELETE clause in the FOREIGN KEY definition, an exception will be thrown when trying to delete rows in the referenced parent table which map to rows in the constrained child table.\n\nON DELETE CASCADE will delete the rows in the constrained child table as well.\n\nON DELETE SET NULL will set the value in the constrained child rows to NULL.\n\nON DELETE RESTRICT will reject the delete and throw an exception -- that is, it will do the same as if you did not include an ON DELETE clause.\n\nON DELETE PURGE is invalid syntax.\n\nON DELETE SET DEFAULT is valid syntax but will do nothing.\n\nOracle Official docs: \"CASCADE: Delete or update the row from the parent table, and automatically delete or update the matching rows in the child table. Both ON DELETE CASCADE and ON UPDATE CASCADE are supported. Between two tables, do not define several ON UPDATE CASCADE clauses that act on the same column in the parent table or in the child table.\n\nSET NULL: Delete or update the row from the parent table, and set the foreign key column or columns in the child table to NULL. Both ON DELETE SET NULL and ON UPDATE SET NULL clauses are supported.\n\nRESTRICT: Rejects the delete or update operation for the parent table. Specifying RESTRICT (or NO ACTION) is the same as omitting the ON DELETE or ON UPDATE clause.\n\nSET DEFAULT: This action is recognized by the MySQL parser, but InnoDB rejects table definitions containing ON DELETE SET DEFAULT or ON UPDATE SET DEFAULT clauses.\"\n","id":72},
{"explanation":"Without an ON DELETE clause in the FOREIGN KEY definition, an exception will be thrown when trying to delete rows in the referenced parent table which map to rows in the constrained child table.\n\nON DELETE SET NULL will set the value in the constrained child rows to NULL.\n\nON DELETE CASCADE will delete the rows in the constrained child table as well.\n\nON DELETE RESTRICT will reject the delete and throw an exception -- that is, it will do the same as if you did not include an ON DELETE clause.\n\nON DELETE NULLIFY is invalid syntax.\n\nON DELETE SET DEFAULT is valid syntax but will do nothing.\n\nOracle Official docs: \"CASCADE: Delete or update the row from the parent table, and automatically delete or update the matching rows in the child table. Both ON DELETE CASCADE and ON UPDATE CASCADE are supported. Between two tables, do not define several ON UPDATE CASCADE clauses that act on the same column in the parent table or in the child table.\n\nSET NULL: Delete or update the row from the parent table, and set the foreign key column or columns in the child table to NULL. Both ON DELETE SET NULL and ON UPDATE SET NULL clauses are supported.\n\nRESTRICT: Rejects the delete or update operation for the parent table. Specifying RESTRICT (or NO ACTION) is the same as omitting the ON DELETE or ON UPDATE clause.\n\nSET DEFAULT: This action is recognized by the MySQL parser, but InnoDB rejects table definitions containing ON DELETE SET DEFAULT or ON UPDATE SET DEFAULT clauses.\"\n","id":73},
{"explanation":"Without an ON DELETE clause in the FOREIGN KEY definition, an exception will be thrown when trying to delete rows in the referenced parent table which map to rows in the constrained child table.\n\nON DELETE RESTRICT will reject the delete and throw an exception -- that is, it will do the same as if you did not include an ON DELETE clause.\n\nON DELETE SET NULL will set the value in the constrained child rows to NULL.\n\nON DELETE CASCADE will delete the rows in the constrained child table as well.\n\nON DELETE THROW EXCEPTION is invalid syntax.\n\nON DELETE SET DEFAULT is valid syntax but will do nothing.\n\nOracle Official docs: \"CASCADE: Delete or update the row from the parent table, and automatically delete or update the matching rows in the child table. Both ON DELETE CASCADE and ON UPDATE CASCADE are supported. Between two tables, do not define several ON UPDATE CASCADE clauses that act on the same column in the parent table or in the child table.\n\nSET NULL: Delete or update the row from the parent table, and set the foreign key column or columns in the child table to NULL. Both ON DELETE SET NULL and ON UPDATE SET NULL clauses are supported.\n\nRESTRICT: Rejects the delete or update operation for the parent table. Specifying RESTRICT (or NO ACTION) is the same as omitting the ON DELETE or ON UPDATE clause.\n\nSET DEFAULT: This action is recognized by the MySQL parser, but InnoDB rejects table definitions containing ON DELETE SET DEFAULT or ON UPDATE SET DEFAULT clauses.\"\n","id":74},
{"explanation":"0 will throw a check constraint errors because it is not \"IN (1,2)\".\n\n1 is \"IN (1,2)\" so it would not throw a check constraint error.\n\n2 is \"IN (1,2)\" so it would not throw a check constraint error.\n\n'my_value' will throw an invalid number error, not a check constraint error.\n\nThe \"my_status IN (1,2)\" is the equivalent of \"my_status = 1 OR my_status = 2\". When my_status = NULL, the logic becomes \"NULL = 1 OR NULL = 2\". NULL = <anything> always evaluates to UNKNOWN. Check constraint errors are only thrown if the logic evaluates to FALSE. Because a NULL input causes the CHECK condition to evaluate to UNKNOWN instead of FALSE, no errors are thrown and we are allowed to insert the value.\n\n","id":75},
{"explanation":"3 will throw a check constraint errors because it causes the \"BETWEEN 1 AND 2\" statement to evaluate to FALSE.\n\nThe BETWEEN statement is inclusive, so an input of either 1 or 2 causes \"BETWEEN 1 AND 2\" to evaluate to TRUE, thus throwing no errors.\n\n\nThe NUMBER data type has the optional parameters NUMBER(precision, scale). Precision is the total number of digits and Scale is the number of digits to the right of the decimal point that the number should be rounded to. When Precision is defined but Scale isn't, Scale = 0. You can specify a Scale with no Precision by using NUMBER(*, scale). When neither are defined, the number is taken as-is.  my_status is of data type NUMBER(1). This means that Precision = 1 and Scale = 0. Because precision = 1, we are allowed only 1 digit, but because scale = 0, we round to the 0th decimal place, causing 1.5 to round up to 2. An input of 2 causes \"BETWEEN 1 AND 2\" to evaluate to TRUE, thus throwing no errors.\n\nThe \"my_status BETWEEN 1 AND 2\" statement is the equivalent of \"my_status >= 1 AND my_status <= 2\". When my_status = NULL, the logic becomes \"NULL >= 1 AND NULL <= 2\". Using the <= or >= relational operators with a NULL argument always evaluates to UNKNOWN. Check constraint errors are only thrown if the logic evaluates to FALSE. Because a NULL input causes the CHECK condition to evaluate to UNKNOWN instead of FALSE, no errors are thrown and we are allowed to insert the value.","id":76},
{"explanation":"None of the columns in UNIQUE, PRIMARY KEY or FOREIGN KEY constraints can be a LOB type, LONG, LONG RAW, VARRAY, NESTED TABLE, BFILE, REF, TIMESTAMP WITH TIME ZONE, or a user-defined type.","id":77},
{"explanation":"Attempting to drop a column from a references parent table in a FOREIGN KEY relationship will throw an error if CASCADE CONSTRAINTS is not added to the DROP COLUMN clause (which will then drop the FOREIGN KEY constraint).\n\nHowever, trying to drop a column from the constrained child table is no problem and does not require CASCADE CONSTRAINTS, as it will automatically drop the column and the FOREIGN KEY constraint.\n\nALTER TABLE DROP (<column_1>, <column_2>...); is valid syntax and can be used to drop multiple columns.\n\nYou cannot drop all columns in a table; attempting to do so will throw an error.","id":78},
{"explanation":"The correct answer is 2: one CHECK constraint and one PRIMARY KEY constraint.\n\nThe code does not throw an error: you can freely drop FOREIGN KEY constrained columns on the CHILD table (my_table_2), but not on the PARENT table (my_table_1). If you were to drop the column from my_table_1, you would have required a CASCADE CONSTRAINT clause, but for my_table_2 the column dropping statement works without error.\n\nPrior to dropping my_status, my_table_2 had 5 constraints: PRIMARY KEY and CHECK constraints on my_id and NOT NULL, FOREIGN KEY and UNIQUE constraints on my_status. When my_status was dropped the latter 3 constraints were dropped with it, leaving only the constraints on my_id.","id":79},
{"explanation":"The execution fails because my_status is part of a multicolumn constraint. In fact, it is part of 2 multicolumn constraints: my_fk and my_pk2. However, if my_status had been in just one, execution still would have failed.\n\nIn order to drop my_status, you would need to include a CASCADE CONSTRAINTS clause, which would have dropped both my_fk and my_pk2, leaving no constraints on my_table_2.","id":80},
{"explanation":"Because CASCADE CONSTRAINTS was added to the DROP COLUMN statement, the query executes successfully. Had CASCADE CONSTRAINTS not been included, the query would have failed because columns used in multicolumn constraints cannot be dropped.\n\nThe CASCADE CONSTRAINTS statement caused my_fk and my_pk2 to be dropped because they referenced my_status. Afterwards, my_table_2 was left with no more constraints.","id":81},
{"explanation":"Setting a column to be UNUSED makes it permanently unusable. The statement cannot be reversed, not even by ROLLBACK or an ALTER TABLE statement.\n\nAn UNUSED column's name is deleted so a new column can use that name, but they still count towards the table's maximum column limit. Constraints and indices are automatically dropped. \n\nOfficial Oracle docs: \"If you are concerned about the length of time it could take to drop column data from all of the rows in a large table, you can use the ALTER TABLE...SET UNUSED statement. This statement marks one or more columns as unused, but does not actually remove the target column data or restore the disk space occupied by these columns. However, a column that is marked as unused is not displayed in queries or data dictionary views, and its name is removed so that a new column can reuse that name. All constraints, indexes, and statistics defined on the column are also removed.\"","id":82},

//error in 83 -- columns can be set unused if they are constrained by a single column constraint. Only stopped by multicolumn constraints

{"explanation":"Setting a column to be UNUSED makes it permanently unusable and cannot be recovered. The statement cannot be reversed, not even by ROLLBACK or an ALTER TABLE statement.\n\nA column that has been set UNUSED can be dropped at a later date using the ALTER TABLE... DROP UNUSED COLUMNS command.\n\nA column cannot be set unused if it is part of a multicolumn constraint, such as a PRIMARY KEY on more than one column. However, it can be set unused if it is part of a single column constraint, such as NOT NULL.\n\nAny number of columns can be set as UNUSED.\n\nYou cannot set a table's final column to be unused. Every table must have at least one usable column.\n\nOfficial Oracle docs: \"If you are concerned about the length of time it could take to drop column data from all of the rows in a large table, you can use the ALTER TABLE...SET UNUSED statement. This statement marks one or more columns as unused, but does not actually remove the target column data or restore the disk space occupied by these columns. However, a column that is marked as unused is not displayed in queries or data dictionary views, and its name is removed so that a new column can reuse that name. All constraints, indexes, and statistics defined on the column are also removed.\"","id":83},
{"explanation":"External tables allow you to query data stored outside the database as if were stored in a table. The metadata which defines the structure is stored inside the database, while the actual data is stored externally.\n\nA VIEW is a table-like object which is defined only logically, by a query, and contains no physical data.\n\nA CLUSTER is a schema object that contains data from one or more tables (and is not on the 1Z0-071 exam).\n\nA DIRECTORY defines a location on the server file system which external resources can be stored.\n\nThere is no such Oracle object as a DISTRIBUTED TABLE.","id":84},

//ambiguity in 85 -- external tables can call SET COLUMN UNUSED but it is equivalent to DROP COLUMN. External Tables are also not read-only. After 10g, they were writable
// more external table questions
{"explanation":"You cannot add a LONG, LOB, or object type column to an EXTERNAL TABLE or change the datatype of an EXTERNAL TABLE's column to any of these datatypes.\n\nYou cannot add a constraint to an external table.\n\nYou CAN add, drop or modify columns of an EXTERNAL TABLE. \n\nYou can use the SET COLUMN UNUSED command on an external table, however the command does not actually set the column to be UNUSED and instead functions exactly as a DROP COLUMN command.\n\nIndexes cannot be made on EXTERNAL TABLEs. From the official Oracle docs: \"You can, for example, select, join, or sort external table data. You can also create views and synonyms for external tables. However, no DML operations (UPDATE, INSERT, or DELETE) are possible, and no indexes can be created, on external tables.\"\n\nPrior to Oracle 10g, EXTERNAL TABLEs were read-only. However, they became writable post-10g. That being said, Oracle official documents explicitly state \"Oracle Database allows you read-only access to data in external tables\", which clearly conveys that they cannot be written to. However, Oracle official documents also state \"The second access driver, ORACLE_DATAPUMP, lets you unload data—that is, read data from the database and insert it into an external table\", which clearly states that data can be inserted into the EXTERNAL TABLE only through the ORACLE_DATAPUMP driver. You definitely can insert data using ORACLE_DATAPUMP, which must not invalidate Oracle's label of \"read-only\". Be very careful of this ambiguity when taking the exam.\n\n","id":85},
{"explanation":"From the official Oracle docs: \"You can, for example, select, join, or sort external table data. You can also create views and synonyms for external tables. However, no DML operations (UPDATE, INSERT, or DELETE) are possible, and no indexes can be created, on external tables.\"\n\nWhile ALTER TABLE ... SET UNUSED is allowed on EXTERNAL TABLEs, it functions exactly the same as DROP COLUMN.","id":86},
{"explanation":"You cannot add a LONG, LOB, or object type column to an EXTERNAL TABLE or change the datatype of an EXTERNAL TABLE column to any of these datatypes.","id":87},
{"explanation":"A DIRECTORY defines a location on the server file system which external resources can be stored.\n\nEXTERNAL TABLES allow you to query data stored outside the database as if were stored in a table. The metadata which defines the structure is stored inside the database, while the actual data is stored externally.\n\nThe is no such Oracle object as a FILE (however, there are PFILE and SPFILE objects which are not covered on the exam).\n\nThe is no such Oracle object as a FILEPATH.\n\n\nThe is no such Oracle object as a LOCATION.","id":88},
{"explanation":"The only object which can support a CONSTRAINT is a TABLE. This excludes the EXTERNAL TABLE object, which does not support the use of CONTRAINTs.","id":89},


//include this: VARCHAR is reserved by Oracle to support distinction between NULL and empty string in future, as ANSI standard prescribes.
{"explanation":"Unquoted object names must always start with a letter, so \"CREATE TABLE $my_table...\" is invalid.\n\n\"$ create table\" and \"my table\" are valid object names ONLY because they are quoted.\n\nIf you were wondering, all column definitions are correct. A NUMBER data type definition is allowed between 0 and 2 optional parameters: NUMBER(precision, scale). A VARCHAR2 data type definition requires a mandatory parameter: VARCHAR2(size).","id":90},
{"explanation":"A CONSTRAINT has no corresponding CREATE statement. You can only instantiate a CONSTRAINT in a CREATE TABLE or ALTER TABLE statement.\n\nThere is no ROW database object and thus has no corresponding CREATE statement.\n","id":91},
{"explanation":"On line 1, three objects will be created: a TABLE named my_table, a CONSTRAINT named my_obj and an INDEX named my_obj (The PRIMARY KEY instantiation creates the latter two with the same name). CONSTRAINT and INDEX objects have different namespaces, so there is no conflict.\n\nOn line 2, a VIEW will be created called my_obj. Even though we already have a CONSTRAINT named my_obj AND an INDEX named my_obj, VIEW objects are in a different namespace than CONSTRAINT and INDEX objects, so there is no conflict. \n\nOn line 3, an INDEX called my#other#obj is created. Because we have no other objects created with this name, there is obviously no conflict. (And if you were wondering, my#other#obj is indeed a valid object name.)\n\nOn line 4, a TABLE is created with the name my#other#obj. TABLE objects and INDEX objects are in different namespaces, so there is no conflict.","id":92},
{"explanation":"On line 1, we create a TABLE object named my_obj.\n\nOn line 2, we create two objects: a CONSTRAINT object named my_obj and an INDEX object also named my_obj (The PRIMARY KEY instantiation creates the latter two with the same name). Even though we already have a TABLE named my_obj, TABLES, INDEXES and CONSTRAINTS are all in different namespaces, so there is no conflict.\n\nOn line 3, we create a VIEW named my_obj. VIEW objects and TABLE objects share a namespace when inside the same schema, so there is a naming conflict with the TABLE my_obj that was created in line 1.\n\n","id":93},
{"explanation":"TABLE and INDEX objects have different namespaces, so there is no conflict.","id":94},
{"explanation":"On line 1, we create a TABLE object named my_obj.\n\nOn line 2, we create 2 objects named my_obj: a CONSTRAINT object and an INDEX object (The PRIMARY KEY instantiation creates the latter two with the same name). TABLES, INDEXES and CONSTRAINTS are all in different namespaces, so there is no conflict.\n\nOn line 3, we attempt to create an INDEX named my_obj. However, we have already created an INDEX named my_obj in the PRIMARY KEY instantiation in line 2, so there is a conflict.","id":95},
{"explanation":"On line 1, we create a TABLE object named my_obj.\n\nOn line 2, we create a CONSTRAINT object called my_obj. CONSTRAINTS and TABLES are in different namespaces, so there is no conflict.\n\nOn line 3, we create an INDEX named my_obj. TABLES, CONSTRAINTS and INDEXES are all in different namespaces, so there is no conflict.","id":96},
{"explanation":"On line 1, we create a TABLE object named my_obj.\n\nOn line 2, we create 2 objects named my_obj: a CONSTRAINT object and an INDEX object (The PRIMARY KEY instantiation creates the latter two with the same name). TABLES, INDEXES and CONSTRAINTS are all in different namespaces, so there is no conflict.","id":97},
{"explanation":"ROLES and USERS share the same nonschema namespace. There are no other object types in this namespace.\n\nPUBLIC SYNONYMS are in their own nonschema namespaces separate from ROLES and USERS.\n\nROLES are always nonschema objects; in fact, there are no objects which can be either schema or nonschema.","id":98},
{"explanation":"This is a perfectly valid CREATE TABLE statement. The only possible concerns might be the data type definitions of CHAR(2) and VARCHAR2(10). CHAR data type definitions take in 1 optional parameter: CHAR(size). VARCHAR2 data type definitions take in 1 mandatory paramater: VARCHAR2(size).","id":99},
{"explanation":"LOB objects cannot by used as primary keys, so line 2 is invalid. \n\nVARCHAR2 data type definitions take in a mandatory parameter: VARCHAR2(size). This is missing in line 4, so that line is incorrect.","id":100},
{"explanation":"LOB objects cannot have UNIQUE constraints applied to them, so line 3 is invalid.\n\nAlso, if you were wondering, it is valid for a NUMBER data type definition to have a negative Scale parameter, as is present in line 2. ","id":101},
{"explanation":"A PRIMARY KEY constraint enforces non-nullability, so \"CREATE TABLE my_table (my_data CHAR, CONSTRAINT my_c PRIMARY KEY (my_data));\" is correct.\n\nThe expression \"my_data IS NOT NULL\" evaluates to FALSE when my_data = NULL, so \"CREATE TABLE my_table (my_data CHAR, CONSTRAINT my_c CHECK (my_data IS NOT NULL));\" is correct.\n\nNOT NULL constraints cannot be created out-of-line in a CREATE TABLE statement, so \"CREATE TABLE my_table (my_data CHAR, CONSTRAINT my_c NOT NULL (my_data));\" is incorrect.\n\nUNIQUE constraints do not enforce non-nullability, so \"CREATE TABLE my_table (my_data CHAR, CONSTRAINT my_c UNIQUE (my_data));\" is incorrect.","id":102},
{"explanation":"LOB objects cannot by used as primary keys, so line 2 is invalid. \n\nVARCHAR2 data type definitions take in a mandatory parameter: VARCHAR2(size). This is missing in line 4, so that line is incorrect.","id":103},

// ambiguity in 104 -- make "It keeps data in the table's indexes in tact." less ambiguous. Change to: "It does not truncate any associated indexes"
// also take out underscore in FLASHBACK TABLE

{"explanation":"TRUNCATE is a DDL statement at the table level and fires no DML triggers, which are at the row level. \n\nTRUNCATE TABLE will remove all rows in a table, but you can also TRUNCATE partitions and subpartitions of a table by using a different command.\n\nOracle official docs: \"when the table is truncated, the index is also truncated, and a new high water mark is calculated for the index segment.\"\n\nOracle official docs: \"You cannot roll back a TRUNCATE TABLE statement, nor can you use a FLASHBACK TABLE statement to retrieve the contents of a table that has been truncated.\"","id":104},

// in 105, remove the underscores from DROP_ANY_TABLE. 
//Also change "It requires the DROP_ANY_TABLE privilege." to "If the table is not in your schema, the statement requires the DROP_ANY_TABLE privilege."
// also change "It deletes rows even if there is an integrity constraint violation." to "It deletes rows even if there is an referential integirty violation."
{"explanation":"To truncate a table, the table must be in your schema or you must have DROP ANY TABLE system privilege.\n\nTRUNCATE TABLE is a DDL statement and therefore performs an implicit commit.\n\nThe TABLE keyword is required when trying to TRUNCATE a table. Attempting to execute TRUNCATE <table_name> is a syntax error.\n\nOracle official docs: \"You cannot truncate the parent table of an enabled foreign key constraint. You must disable the constraint before truncating the table. An exception is that you can truncate the table if the integrity constraint is self-referential.\"\n\nOracle official docs: \"You cannot roll back a TRUNCATE TABLE statement, nor can you use a FLASHBACK TABLE statement to retrieve the contents of a table that has been truncated.\"","id":105},
{"explanation":"You cannot truncate the parent table of an enabled foreign key constraint, so line 7 fails. However, the TRUNCATE command performs an implicit commit even in the case of failure, so line 6 is now committed.","id":106},
{"explanation":"Line 6 inserts the number 1 into my_table_1.my_id. Because there is no corresponding row in my_table_2.my_id which references that row, then there is no referential integrity error. If there had been an \"INSERT INTO my_table_2 VALUES (1);\" command between lines 6 and 7, then there would have been an integrity violation on \"DELETE FROM my_table_1;\" due to the FOREIGN KEY constraint on my_table_2.\n\n\nDELETE is a DML statement and as such does not perform an implicit commit. Therefore, line 6 has not been committed after line 7.","id":107},
{"explanation":"TRUNCATE statements fail only when performed on the PARENT table of a FOREIGN KEY constraint. Because line 8 truncates on my_table_2, the child table in the referential relationship, it will not throw an error. Had the TRUNCATE statement been on my_table_1, line 8 would have thrown an error.\n\nTRUNCATE is a DDL statement and as such performs an implicit commit. So once line 8 executes, the DML inserts at lines 6 and 7 are committed. Note that TRUNCATE implicitly commits even if the statement fails, so line 6 would have been committed even if there had been a referential constraint.","id":108},


//in 109, make "The inserted value data types only have to be compatible with the table's columns, not identical." less ambiguous
//take out "The "VALUES" keyword is optional."
{"explanation":"If you leave out columns in your INSERT INTO... VALUES... statement, all excluded columns will be set to null. Therefore, Nullable columns are optional in an INSERT INTO... VALUES... statement, while Non-Nullable columns are mandatory and would throw a \"Cannot insert NULL\" exception if excluded.\n\nThe values that are inserted using an INSERT INTO... VALUES... command will automatically convert to the data types of the table's columns (as long as the two data types are compatible).\n\nINTO is a mandatory keyword. Excluding it will cause a syntax failure.\n\nData definition language (DDL) statements let you manipulate database objects or privileges. Data manipulation language (DML) statements access and manipulate data in existing schema objects. Because INSERT is used to add data to a table, it is considered a DML command, not a DDL command.","id":109},
{"explanation":"The PRIMARY KEY on my_id instantiated on line 2 enforces uniqueness on that column. So once line 4 already inserts 1 into my_table.my_id, line 5 will fail when it tries to insert the same value.\n\nThere are no COMMIT or DDL statements at or after line 5, so it could not be committed.","id":110},
{"explanation":"This question concerns the fact that line 4 inserts a CHAR value into my_id, which is has NUMBER data type. Because '1' is a character representation of a number, Oracle can and will implicitly convert it into a NUMBER data type before inserting it. Therefore, there is no error.\n\nThere are no COMMIT or DDL statements at or after line 5, so it could not be committed.","id":111},
{"explanation":"This question concerns the fact that line 4 inserts a NUMBER value into my_id, which is has CHAR data type. Oracle can and will implicitly convert the NUMBER value 1 into the CHAR value '1' before inserting it. Because line 3 already has inserted the CHAR value '1' on line 3, this violates the in-line UNIQUE constraint defined on line 2, causing line 4 to fail.\n\nThere are no COMMIT or DDL statements at or after line 4, so it could not be committed.","id":112},
{"explanation":"The CHECK constraint in line 2 evaluates an IN condition on two NUMBER values: 1 and 2. When line 3 attempts to insert the CHAR value '1' into my_id, the \"my_id IN (1,2)\" clause evaluates ('1' = 1 OR '1' = 2). Note that Oracle's implicit type conversion causes '1' = 1 to evaluate to true, so the CHECK constraint does not fail. \n\nThere are no COMMIT or DDL statements at or after line 3, so it could not be committed.","id":113},
{"explanation":"Line 3 fails because you are missing the VALUES keyword.","id":114},

//115 clear up ambiguity in "After line 6, there are two records in my_table."
{"explanation":"Official Oracle docs: \"Unless a NOT NULL constraint is also defined, a null always satisfies a unique key constraint. Thus, columns with both unique key constraints and NOT NULL constraints are typical. This combination forces the user to enter values in the unique key and eliminates the possibility that new row data conflicts with existing row data.\"\n\nKeep in mind that NULL = NULL never evaluates to TRUE or FALSE, but rather to UNKNOWN.\n\nAfter line 6, there are 3 rows in the table: two NULL rows and one row containing 'A'.\n\nThere are no COMMIT or DDL statements at or after line 3, so it could not be committed.","id":115},
{"explanation":"An UPDATE statement can only take one table as a parameter. \n\nIf an UPDATE statement changes one row to violate any constraint condition, then the entire UPDATE statement will not be accepted and it will make no modifications to the table.\n\nIf an UPDATE statement matches to 0 rows or updates 0 rows, no exception will be thrown.\n\nAn UPDATE statement, unlike an INSERT statement, does not need to specify values for all NOT NULL columns.\n\nUPDATE is a DML statement and therefore does not automatically commit after execution.\n\n","id":116},
{"explanation":"DML statements, such as INSERT, UPDATE and MERGE can be undone using a ROLLBACK command.\n\nDDL statements such as TRUNCATE and CREATE implicitly commit after execution and cannot be reverted with the ROLLBACK command.","id":117},
{"explanation":"At line 3, the value 'A' is inserted into my_id.\n\nAt line 4, a COMMIT is executed, saving the DML change in line 3.\n\nAt line 5, the value 'B' is inserted into my_id.\n\nAt line 6, a ROLLBACK is executed, reverting the DML changes in line 5. The changes in line 3 have already been committed by line 4, so they are not reverted and 'A' is still stored in the table.\n\nLine 7 attempts to insert 'A' into my_id, but because 'A' already exists in the table this violates the UNIQUE constraint on my_id, causing an error.\n","id":118},
{"explanation":"This question concerns the DDL status of the GRANT and CREATE USER statements.\n\nThe GRANT statement on line 5 performs an implicit commit, saving the 'A' value inserted in line 4 and causing it to not be reverted by the ROLLBACK on line 6. Thus, when line 7 attempts to insert 'A' into my_id, the UNIQUE constraint on that column is violates, causing an error.\n\nLine 8 attempts to create a USER named my_user, even though we already created a USER object with the same name in line 1. The ROLLBACK in line 6 does not undo the CREATE USER statement in line 1 because (a) CREATE USER is a DDL statement and can't be rolled back and (b) there is an implicit commit at line 5 so even if CREATE USER were a DML statement, line 1 would still be saved.","id":119},
{"explanation":"At line 3, we insert 'A' into my_table.my_id.\n\nAt line 4, we DROP my_table. DROP is a DDL statement so it performs an implicit commit.\n\nAt line 5, we call ROLLBACK. This doesn't revert our DROP TABLE command on line 4 because DROP TABLE is a DDL statement, so my_table is still dropped,\n\nLine 6 attempts to insert 'A' into my_table.my_id. However, because my_table was dropped in line 4, this causes an error.","id":120},
{"explanation":"At line 3, we insert 'A' into my_table.my_id.\n\nAt line 4, we DROP my_table. DROP is a DDL statement so it performs an implicit commit.\n\nAt line 5, we call ROLLBACK. This doesn't revert our DROP TABLE command on line 4 because DROP TABLE is a DDL statement, so my_table is still dropped,\n\nLine 6 attempts to insert 'A' into my_table.my_id. However, because my_table was dropped in line 4, this causes an error.","id":120},

//error at 121: Line 6 does not fail
{"explanation":"At line 4, the mandatory keyword \"TABLE\" is missing. This means that the TRUNCATE command isn't even recognized so there is no implicit commit.\n\nLine 3 is reverted by the ROLLBACK at line 5 so there is no unique constraint error at line 6.","id":121},
{"explanation":"You cannot truncate a table which is the parent in a FOREIGN KEY relationship, so line 7 fails. However, even though it fails, the TRUNCATE command still makes an implicit commit.\n\nBecause line 7 causes an implicit commit, the DML changes in line 6 are not reverse by the ROLLBACK in line 8. Therefore the attempted INSERT in line 9 will cause a unique constraint violation.","id":122},

//misspelling at 123: nonexistant should be nonexistent
{"explanation":"There is no such table as nonexistent_table, so the TRUNCATE at line 4 fails. However, even though it fails, the TRUNCATE command still makes an implicit commit.\n\nBecause line 4 causes an implicit commit, the DML changes in line 3 are not reverse by the ROLLBACK in line 5. Therefore the attempted INSERT in line 3 will cause a unique constraint violation.","id":123},
{"explanation":"The ALTER TABLE command a line 6 is a DDL statement which causes an implicit commit.\n\nBecause line 4 causes an implicit commit, the DML changes in line 3 are not reverse by the ROLLBACK in line 5. Therefore the attempted INSERT in line 6 will cause a unique constraint violation.","id":124}
{"explanation":"The INSERT at line 6 is reverted by the ROLLBACK at line 7, so there is no unique constraint violation when the INSERT at line 9 is executed.","id":125},
{"explanation":"The ALTER TABLE command at line 7 causes an implicit commit because it is a DDL statement. Therefore, by the time we execute the ROLLBACK at line 8, the savepoint MARK1 has been invalidated and will throw a \"savepoint 'MARK1' never established in this session or is invalid\" exception. \n\nBecause the rollback did not succeed, and also because of the commit at line 7, the DML INSERT at line 6 has been saved. So the INSERT at line 9 will throw a UNIQUE constraint violation error.\n","id":126},
{"explanation":"There is no such table as nonexistent_table, so the TRUNCATE at line 5 fails. However, even though it fails, the TRUNCATE command still makes an implicit commit.\n\nBecause of the commit at line 5, the savepoint MARK1 has been invalidated, so line 6 will throw a \"savepoint 'MARK1' never established in this session or is invalid\" exception.\n\nBecause the DML statement at line 4 was committed by line 5, line 7 will violate the unique constraint defined in line 2. ","id":127},
{"explanation":"There is no commit between line 3 and line 5 so the ROLLBACK command will execute successfully and revert the DML statement at line 4.\n\nBecause the INSERT at line 4 has been reverted, the INSERT at line 6 will not throw a unique constraint violation error.","id":128},
{"explanation":"The CREATE TABLE statement is perfectly valid. The only concern might be that 1234 is being inserted into a VARCHAR2(10) data type, but Oracle would implicitly convert the entry.","id":129},
{"explanation":"The mandatory VALUES keyword is missing.","id":130},
{"explanation":"he statements are perfectly valid. Both my_id and my_name enforce uniqueness, and the two INSERT statements have different values for these columns.\n\nThere might be a concern that 1234 is being inserted into a VARCHAR2(10) data type, but Oracle would implicitly convert the entry.","id":131},
{"explanation":"WHERE clauses are optional. \n\nVALUES is not mandatory when not supplying hard-coded values to be inserted. INSERT INTO <table> (<select query>); is valid syntax.\n\nINSERT and INTO are both mandatory keywords.","id":132},


//error at 133: WHERE is not required for delete
{"explanation":"Not only is TABLE not required, but including it would be invalid syntax.\n\nFROM is an optional keyword. DELETE <table_name> is valid syntax.\n\nWHERE is optional because the WHERE clause in a DELETE statement is optional.\n\nDELETE is mandatory.","id":133},
{"explanation":"WHERE is optional because the WHERE clause in a UPDATE statement is optional.\n\nIN is a conditional operator and is never required.\n\nUPDATE and SET are both required.","id":134},
{"explanation":"ORDER BY statements take priority in their column lists from left to right, so this statement will sort by my_data1 first and then by my_data2.\n\nIf ASC or DESC is not defined, then the defaulted sort is ASC. Therefore, we are sorting the data first by my_data1 ASC and then by my_data2 DESC.\n\nIt is perfectly allowed to ORDER BY some columns which are not in your SELECT list.\n\nGROUP BY is definitely not necessary in this query since we are returning only one column, so there is no chance of an aggregation level conflict.\n\n","id":135},
{"explanation":"Certain expressions are allowed in the ORDER BY clause, such as \"ORDER BY my_data2 + 1\", but LIKE is not allowed. Even if it were, the question's usage is incorrect and makes no sense.\n\nIt is perfectly allowed to ORDER BY some columns which are not in your SELECT list.\n\nGROUP BY is definitely not necessary in this query since we are returning only one column, so there is no chance of an aggregation level conflict.\n\n","id":136},


//errors at  137

{"explanation":"ORDER BY statements are always optional. \n\nIt is perfectly allowed to ORDER BY some columns which are not in your SELECT list.\n\n","id":138},
{"explanation":"The clause \"WHERE my_data IN ('my_data1', 'my_data2', '%data3')\" is not a LIKE statement. It is equivalent to (my_data = 'my_data1' OR my_data  = 'my_data2' OR my_data = '%data3'). \n\n'my_data3' = '%data3' evaluates to FALSE. 'my_data3' LIKE '%data3'  would evaluate to TRUE, but that is not in the WHERE clause.\n\nTherefore, the select statement returns two rows: 'my_data1' and 'my_data2'.","id":139},


//maybe at some point include more practice on ascii table weights, and general sorting weight information for all datatypes
//add some practice on oracle boolean truth tables with unknown
{"explanation":"A descending order means that the highest ranking values are returned first.\n\nOracle sorts based on ASCII weights. In ASCII, all uppercase letters come before all lowercase letters and therefore have  lower weights. So 'me' would return before 'You' in a descending sort because a lowercase 'm' has a higher weight than an uppercase 'Y'.\n\nOracle weights later dates higher, so January 2nd 2000 returns before January 1st 2000 in a descending sort.\n\n'You' is weighted higher than 'Me' in a descending sort because uppercase 'Y' comes after uppercase 'M'. Therefore, 'Me' does not return before 'You'.\n\nIt is important to realize that '100' and '50' are taken as CHARACTER data, not numbers, and as such are weighted only by their first character. Because '5' obviously comes after '1', '50' would return before '100' in a descending sort.\n\nNUMBER values take their weight as straight numerical comparisons, so 2 obviously weights higher than 1 and would be returned first in a descending sort.","id":140},
{"explanation":"The clause \"WHERE my_data IN ('my_data1', 'my_data2', '%data3')\" is not a LIKE statement. It is equivalent to (my_data = 'my_data1' OR my_data  = 'my_data2' OR my_data = '%data3'). \n\n'my_data3' = '%data3' evaluates to FALSE. 'my_data3' LIKE '%data3'  would evaluate to TRUE, but that is not in the WHERE clause.\n\nTherefore, the select statement returns two rows: 'my_data1' and 'my_data2'.","id":141},
{"explanation":"This question concerns the behavior of NULL values. \n\nWhen the SELECT statement executes, my_table will have the following entries: ['my_data1', NULL, 'my_data3'].\n\nFor a record to pass the WHERE clause in the SELECT statement, it must evaluate to true either in my_data = NULL or my_data = 'my_data3'. Obviously 'my_data1' doesn't fit either of these, so it is excluded. \n\nThe main point of this question is that NULL = NULL does NOT evaluate to TRUE. It evaluates to UNKNOWN. So the NULL entry in my_table does not pass the WHERE clause. \n\nWhen 'my_data3' is passed in, the boolean logic is calculated as such:\n\n('my_data3' = NULL OR 'my_data3' = 'my_data3')\n\nwhich becomes\n\n(UNKNOWN OR TRUE).\n\nThe Oracle truth tables calculate (UNKNOWN OR TRUE) as TRUE, so 'my_data3' passes the WHERE condition and is the only value to do so.","id":142},
{"explanation":"For anything to be returned by the SELECT query, the WHERE clause must return true. Remember that anything = NULL always returns UNKNOWN (including NULL = NULL), so nothing will ever be returned by this select query.","id":143},
{"explanation":"Firstly, Oracle evaluates empty strings and NULL values interchangeably, so for all purposes the first INSERT places a NULL record in my_table.\n\nThis also means that the third INSERT statement evaluates ('my_data3' || NULL) as ('my_data3' || ''), which in turn evaluates to 'my_data3'\n\nSo after the INSERT statements, there are three values in my_table: [NULL, NULL, 'my_data3'].\n\n(NULL IS NULL) evaluates to TRUE and ('my_data3' IS NULL) evaluates to FALSE, so the first two record are returned.","id":144},
{"explanation":"Firstly, Oracle evaluates empty strings and NULL values interchangeably, so for all purposes the first INSERT places a NULL record in my_table.\n\nThis also means that the third INSERT statement evaluates ('my_data3' || NULL) as ('my_data3' || ''), which in turn evaluates to 'my_data3'\n\nSo after the INSERT statements, there are three values in my_table: [NULL, NULL, 'my_data3'].\n\n(NULL IS NULL) evaluates to TRUE and ('my_data3' IS NULL) evaluates to FALSE, so the first two record are returned.","id":145},
{"explanation":"Firstly, Oracle evaluates empty strings and NULL values interchangeably, so for all purposes the first INSERT places a NULL record in my_table.\n\nThis also means that the third INSERT statement evaluates ('my_data3' || NULL) as ('my_data3' || ''), which in turn evaluates to 'my_data3'\n\nSo after the INSERT statements, there are three values in my_table: [NULL, NULL, 'my_data3'].\n\nFor a record to pass the WHERE clause it must return TRUE. (NULL <> NULL) evaluates to UNKNOWN and ('my_data3' <> NULL) also evaluates to UNKNOWN. No records evaluate to TRUE and thus no records are returned.","id":146},
{"explanation":"Firstly, Oracle evaluates empty strings and NULL values interchangeably, so for all purposes the first INSERT places a NULL record in my_table.\n\nThis also means that the third INSERT statement evaluates ('my_data3' || NULL) as ('my_data3' || ''), which in turn evaluates to 'my_data3'\n\nSo after the INSERT statements, there are three values in my_table: [NULL, NULL, 'my_data3'].\n\nFor a record to pass the WHERE clause it must return TRUE. (NULL IS NOT NULL) evaluates to FALSE and ('my_data3' IS NOT NULL) evaluates to TRUE. One record evaluates to TRUE in the WHERE clause so only one record is returned.","id":147},
{"explanation":"DEFINE specifies a substitution variable and assigns a CHAR value to it, OR\nlists the value and variable type of a single variable or all variables.\n\nSHOW Shows the value of a SQLcl system variable, or the current\nSQLcl environment.\n\nSHOW &, SHOW DEFINE and EXPLAIN & are all invalid SQL commands.","id":148},
{"explanation":"ANY string in a query can be replaced by a defined substitution variable, including keywords, expressions, parameters and even database object names.","id":149},
{"explanation":"UNDEFINE deletes one or more substitution variables that you defined either explicitly (with the DEFINE command), or implicitly (with a START command argument).\n\nSET DEFINE OFF turns off substitution variable functionality but does not delete substitution variables.\n\nDELETE is used to remove rows from a table.\n\nREMOVE is not a real SQL command.\n\nDEREFERENCE is not a real SQL command.","id":150},
{"explanation":"It is perfectly valid to ORDER BY columns not in the select list.\n\nORDER BY clauses always come at the end of a SELECT statement.\n\nORDER BY clauses are always optional.\n\nNULL values are always given the highest sorting weight, so they are sorted last in an ascending sort but first in a descending sort.\n\nORDER BY does not change any data. It only changes the order by which rows are returned in a SELECT statement.","id":151},
{"explanation":"NULL values are always weighted higher than any other values in the column. my_data is sorted DESC, so the highest weighted values are returned first. Therefore, NULL is returned first.","id":152},
{"explanation":"my_data is sorted ASC, so the lowest weighted values are returned first. \n\nNULL values are always weighted higher than any other values in the column, so we know that they will be returned last.\n\n'my_data1' and 'my_data2' are identical strings until the last character, so the sorting comes down to that last character. '1' comes before '2' in ASCII, so it is weighted lower. Therefore 'my_data1' is weighted the lowest and returned first in an ascending sort.","id":153},
{"explanation":"When ASC or DESC are not specified for a column in an ORDER BY clause, thar column is defaulted as sorting to ASC. This means that my_data is sorted ASC, so the lowest weighted values are returned first. \n\nNULL values are always weighted higher than any other values in the column, so we know that they will be returned last.\n\n'my_data1' and 'my_data2' are identical strings until the last character, so the sorting comes down to that last character. '1' comes before '2' in ASCII, so it is weighted lower. Therefore 'my_data1' is weighted the lowest and returned first in an ascending sort.","id":154},
{"explanation":"After the INSERT statements, my_table has the following data in it:\n\n[1, 2, 1]\n[2, 1, 2]\n\nWhen ASC or DESC are not specified for a column in an ORDER BY clause, that column is defaulted as sorting to ASC. Therefore both my_data1 and my_data2 are being sorted ASC.\n\nTake the full dataset, and then order by my_data1 ASC:\n\nRow 1: [1, 2, 1]\nRow 2: [2, 1, 2]\n\nThen, group the above sorted dataset by unique values of my_data1 and sort those subsets by my_data2 ASC:\n\nGroup 1 (my_data1 = 1):\nRow 1: [1, 2, 1]\nGroup 2 (my_data1 = 2):\nRow 1: [2, 1, 2]\n\nBecause there are only two rows, this is a trivial example and the row order remains unchanged from the my_data2 sorting. So the result is:\n\nRow 1: [1, 2, 1]\nRow 2: [2, 1, 2]\n\nThe id value of Row 1 is 1, so our result is 1.","id":155},
{"explanation":"After the INSERT statements, my_table has the following data in it:\n\n[1, 2, 1]\n[2, 1, 2]\n\nWhen ASC or DESC are not specified for a column in an ORDER BY clause, that column is defaulted as sorting to ASC. Therefore both my_data1 and my_data2 are being sorted ASC.\n\nTake the full dataset, and then order by my_data2 ASC:\n\nRow 1: [2, 1, 2]\nRow 2: [1, 2, 1]\n\nThen, group the above sorted dataset by unique values of my_data2 and sort those subsets by my_data1 ASC:\n\nGroup 1 (my_data2 = 1):\nRow 1: [2, 1, 2]\nGroup 2 (my_data2 = 2):\nRow 1: [1, 2, 1]\n\nBecause there are only two rows, this is a trivial example and the row order remains unchanged from the my_data1 sorting. So the result is:\n\nRow 1: [1, 2, 1]\nRow 2: [2, 1, 2]\n\nThe id value of Row 1 is 2, so our result is 2.","id":156},
{"explanation":"After the INSERT statements, my_table has the following data in it:\n\n[1, 2, 1]\n[2, 1, 2]\n\nWhen ASC or DESC are not specified for a column in an ORDER BY clause, that column is defaulted as sorting to ASC. Therefore both my_data1 is being sorted as ASC.\n\nTake the full dataset, and then order by my_data2 DESC:\n\nRow 1: [1, 2, 1]\nRow 2: [2, 1, 2]\n\nThen, group the above sorted dataset by unique values of my_data2 and sort those subsets by my_data1 ASC:\n\nGroup 1 (my_data2 = 2):\nRow 1: [1, 2, 1]\nGroup 2 (my_data2 = 1):\nRow 1: [2, 1, 2]\n\nBecause there are only two rows, this is a trivial example and the row order remains unchanged from the my_data1 sorting. So the result is:\n\nRow 1: [1, 2, 1]\nRow 2: [2, 1, 2]\n\nThe id value of Row 1 is 1, so our result is 1.","id":157},
{"explanation":"After the INSERT statements, my_table has the following data in it:\n\n[1, 2, 1]\n[2, 1, 2]\n\n\nTake the full dataset, and then order by my_data2 ASC:\n\nRow 1: [2, 1, 2]\nRow 2: [1, 2, 1]\n\nThen, group the above sorted dataset by unique values of my_data2 and sort those subsets by my_data1 DESC:\n\nGroup 1 (my_data2 = 1):\nRow 1: [1, 2, 1]\nGroup 2 (my_data2 = 2):\nRow 1: [2, 1, 2]\n\nBecause there are only two rows, this is a trivial example and the row order remains unchanged from the my_data1 sorting. So the result is:\n\nRow 1: [1, 2, 1]\nRow 2: [2, 1, 2]\n\nThe id value of Row 1 is 2, so our result is 2.","id":158},

//more order by questions with 3-5 rows
{"explanation":"When ASC or DESC are not specified for a column in an ORDER BY clause, that column is defaulted as sorting to ASC. So, we are sorting by my_data1 / my_data2 ASC.\n\nAfter the INSERT statements, my_table has the following data in it:\n\n[1, 2, 1]\n[2, 1, 2]\n\nThe my_data1 / my_data2 values for these are as follows:\n\n[1, 2, 1] -> 1/2 = 0.5\n[2, 1, 2] -> 2/1 = 2\n\n0.5 is weighted less than 2, so it is returned first in an ascending sort. So the ranking is:\n\nRow 1: [1, 2, 1]\nRow 2: [2, 1, 2]\n\nThe id value of Row 1 is 1, so our result is 1.","id":159},
{"explanation":"When using the ORDER BY <number> syntax, the number corresponds with the column in the select list at that number's index. Because our example uses ORDER BY 1, we sort by the id column.\n\nWhen ASC or DESC are not specified for a column in an ORDER BY clause, that column is defaulted as sorting to ASC. So, we are sorting by id ASC.\n\nAfter the INSERT statements, my_table has the following data in it:\n\n[1, 2, 1]\n[2, 1, 2]\n\nSorting by id ASC yields:\n\nRow 1: [1, 2, 1]\nRow 2: [2, 1, 2]\n\nThe id value of Row 1 is 1, so our result is 1.","id":160},
{"explanation":"When using the ORDER BY <number> syntax, the number corresponds with the column in the select list at that number's index. Because our example uses ORDER BY 2, but we only have one column in the SELECT list, an error is thrown.","id":161},
{"explanation":"After the INSERT statements, my_table has the following data in it:\n\n[1, 2, 1]\n[2, 1, 2]\n\nWhen ASC or DESC are not specified for a column in an ORDER BY clause, that column is defaulted as sorting to ASC. So, we are sorting by my_data2 - ROWNUM ASC.\n\nBecause [1, 2, 1] was inserted first, it has ROWNUM = 1. [2, 1, 2] has ROWNUM = 2 because it was inserted second.\n\nThus, the my_data2 - ROWNUM evaluations of the rows are as follows:\n\n[1, 2, 1] -> 2 - 1 = 1\n[2, 1, 2] -> 1 - 2 = -1\n\n-1 is weighted lower than 1, so that row is returned first in an ascending sort.\n\nRow 1: [2, 1, 2]\nRow 2: [1, 2, 1]\n\nThe id value of Row 1 is 2, so our result is 2.","id":162},
{"explanation":"Execution fails because we have given the same alias \"my_column\" to 2 different columns in the select list. An \"ambiguous column naming in select list\" exception is thrown.","id":163},
{"explanation":"We are giving id the quoted identifier \"my column\", which is valid.\n\nWhen ASC or DESC are not specified for a column in an ORDER BY clause, that column is defaulted as sorting to ASC. So, we are sorting by id ASC.\n\nAfter the INSERT statements, my_table has the following data in it:\n\n[1, 2, 1]\n[2, 1, 2]\n\nBecause this is an ascending sort, the row with the smallest id value will be returned first. So we have:\n\nRow 1: [1, 2, 1]\nRow 2: [2, 1, 2]\n\nThe id value of Row 1 is 1, so our result is 1.","id":164},


//ambiguity in question 165: add create table statement to explicitly show that there is no my_column column in my_table
{"explanation":"Execution fails because there is no column in my_table named my_column.","id":165},
{"explanation":"The <> relational operator is equivalent to a \"not equals\" condition.\n\nAfter the INSERT statements, my_table has the following data in it:\n\n[1, 2, 1]\n[2, 1, 2]\n\nOne row has my_data1 = 1 and one has my_data1 = 2, so only one record is returned by the select query.","id":166},
{"explanation":"After the INSERT statements, my_table has the following data in it:\n\n[1, 2, 1]\n[2, 1, 2]\n\n[1, 2, 1] was inserted first, so its ROWNUM = 1. [2, 1, 2] was inserted second, so its ROWNUM = 2. \n\nBoth records have ROWNUM = my_data1, so both are returned.","id":167},
{"explanation":"After the INSERT statements, my_table has the following data in it:\n\n[1, 2, 1]\n[2, 1, 2]\n\nIn both rows, my_data1 = id. So there is no case where my_data2 > id, and thus no rows pass the WHERE condition.","id":168},
{"explanation":"After the INSERT statements, my_table has the following data in it:\n\n[30-DEC-2017, 1]\n[30-DEC-2016, 2]\n\n\nWhen ASC or DESC are not specified for a column in an ORDER BY clause, that column is defaulted as sorting to ASC. So, we are sorting by my_date ASC.\n\nDate values are sorted with earlier dates being weighted lower and later dates being weighted higher. 30-DEC-2016 is an earlier date than 30-DEC-2017, so it is ranked lower and thus returned first in an ascending sort.\n\nSo the result is:\n\nRow 1: [30-DEC-2016, 2]\nRow 2: [30-DEC-2017, 1]\n\n\nThe id value of Row 1 is 2, so our result is 2.\n","id":169},
{"explanation":"After the INSERT statements, my_table has the following data in it:\n\n['DATA', 1]\n['data', 2]\n\nCharacter equality operators are case sensitive so 'data' = 'DATA' returns FALSE. 'DATA' = 'DATA' returns true, so 1 record is returned.","id":170},
{"explanation":"After the INSERT statements, my_table has the following data in it:\n\n['DATA', 1]\n['data', 2]\n\nThe underscore '_' character in a pattern matching LIKE statement maps to any single character. 'DATA' matches this pattern so it is returned. 'data' matches to the character length but non-wildcard characters in pattern matching such as the 'A' in '_A__', are still case sensitive. So 'data' LIKE '_A__' evaluates to FALSE.","id":171},
{"explanation":"After the INSERT statements, my_table has the following data in it:\n\n['DATA', 1]\n['data', 2]\n\nThe percent '%' character in a pattern matching LIKE statement maps to any number of any characters. However, any non-wildcard characters, such as the 'a' in '%a%', are still case-sensitive.\n\nSo 'data' LIKE '%a%' evaluates to TRUE, but 'DATA' LIKE '%a%' evaluates to FALSE. So only one record is returned.","id":172},
{"explanation":"\"my_data LIKE '_A_'\" would not work because the underscore '_' character in a pattern matching LIKE statement maps to any single character. 'DATA' has a length of 4 characters, but to match to that pattern it would need to have a length of 3 characters.\n\n\"1 = 1\" would work because it always evaluates to TRUE.\n\n\"my_data LIKE '%T_'\" would work because it requires its input only to have 1 character after the 'T', and any number of characters before it, which 'DATA' does. \n\n\"LOWER(my_data) LIKE '%a%'\" works because 'DATA' is transformed into 'data' prior to the LIKE statement, and thus matches the pattern.\n\n\"my_data = 'DA' || 'TA'\" works because the concatenation resolves before the equality operation, making the evaluation result in TRUE.","id":173},
{"explanation":"\"my_data LIKE 'DATA%'\" works because the percent '%' character in a pattern matching LIKE statement maps to any number of any characters, which includes 0 additional characters.\n\n\"my_data LIKE 'DATA'\" works because, even though there are no wildcard characters, the evaluation still matches each of the hardcoded literal characters.\n\n\"my_data LIKE 'D%A_'\" does not work because it requires exactly one character after the 'A', which is not the case for either of the 'A' characters present in 'DATA'.\n\n\"my_data IS 'DATA'\" is invalid syntax.\n\n\"'%A%' LIKE my_data\" does not work. Wildcard characters must only be placed to the right of the LIKE keyword.","id":174},
{"explanation":"After the INSERT statements, my_table has the following data in it:\n\n[1, 2, 1]\n[2, 1, 2]\n[0, 1, 3]\n\nThe rows where (my_data1 > 0) evaluates to TRUE are:\n\n[1, 2, 1]\n[2, 1, 2]\n\nAnd of those, the row where (my_data2 < 2) evaluates to TRUE is:\n\n[2, 1, 2]\n\n\nThe id value of this row is 2, so our result is 2.\n","id":175},
{"explanation":"After the INSERT statements, my_table has the following data in it:\n\n[0, 2, 1]\n[2, 1, 2]\n[0, 1, 3]\n\nRemember that Oracle's order of operations evaluates NOT before AND, so the WHERE clause can be grouped as:\n\nWHERE (NOT my_data1 > 0) AND (my_data2 < 2)\n\nThe rows where (NOT my_data1 > 0) evaluates to TRUE are:\n\n[0, 1, 3]\n[0, 2, 1]\n\nAnd of those, the row where (my_data2 < 2) evaluates to TRUE is:\n\n[0, 1, 3]\n\nThe id value of this row is 3, so our result is 3.\n","id":176},
{"explanation":"After the INSERT statements, my_table has the following data in it:\n\nRow 1: [0, 1]\nRow 2: [2, 2]\n\nWe want the expressions for which only Row 2 matches.\n\nThe != expression returns true if the operators are not equal. \"my_data != 0\" works because Row 2's my_data column evaluates in the WHERE clause as (2 != 1) = TRUE.\n\nThe <> expression returns true if the operators are not equal and is identical to !=. \"my_data <> 0\" works because Row 2's my_data column evaluates in the WHERE clause as (2 <> 1) = TRUE.\n\n\"NOT my_data = 0\" works because it is equivalent to the above two expressions.\n\n\"my_data IS NOT 0\" is incorrect syntax. IS NOT can only be used as IS NOT NULL.\n\n\n\"my_data NOT = 0\" is incorrect syntax. NOT must be placed to the left of the column name.\n","id":177},
{"explanation":"After the INSERT statements, my_table has the following data in it:\n\n[0, 1, 1]\n[0, 2, 2]\n[1, 1, 3]\n[1, 2, 4]\n\n\nRemember that the Oracle order of operations evaluates AND before OR, so the WHERE clause condition can be grouped as:\n\nWHERE (my_data1 = 0) OR (my_data1 = 1 AND my_data2 = 2)\n\nThe rows for which (my_data1 = 0) evaluates to true are:\n\n[0, 1, 1]\n[0, 2, 2]\n\n\nThe row for which (my_data1 = 1 AND my_data2 = 2) evaluates to true is:\n\n[1, 2, 4]\n\nSo those rows which satisfy (my_data1 = 0) OR (my_data1 = 1 AND my_data2 = 2) is simply the union of those two rowsets:\n\n[0, 1, 1]\n[0, 2, 2]\n[1, 2, 4]\n\nTherefore 3 rows are returned.","id":178},
{"explanation":"After the INSERT statements, my_table has the following data in it:\n\n[0, 1, 1]\n[0, 2, 2]\n[1, 1, 3]\n[1, 2, 4]\n\n\nEven though the Oracle order of operations evaluates AND before OR, the grouping of expressions by parenthesis overrides that ordering.\n\nThe rows for which  (my_data1 = 0 OR my_data1 = 1)  evaluates to true are:\n\n[0, 1, 1]\n[0, 2, 2]\n[1, 1, 3]\n[1, 2, 4]\n\n\nThe rows for which (my_data2 = 2) evaluates to true are:\n\n[0, 2, 2]\n[1, 2, 4]\n\nSo those rows which satisfy  (my_data1 = 0 OR my_data1 = 1) AND (my_data2 = 2) is simply the intersection of those two rowsets:\n\n[0, 2, 2]\n[1, 2, 4]\n\nTherefore 2 rows are returned.","id":179},
{"explanation":"After the INSERT statements, my_table has the following data in it:\n\n[0]\n[10]\n\nWe want a WHERE expression which evaluates to true for both 0 and 10.\n\n\"my_data NOT IN (3)\" works because (NOT 0 = 3) AND (NOT 10 = 3) evaluates to TRUE.\n\n\"my_data BETWEEN 0 AND 10\" works because the BETWEEN operator reduces to (my_data >= 0 AND my_data <= 10), which evaluates to TRUE for both 0 and 10.\n\n\"my_data IN (0, 10)\" works because  IN reduces to ((my_data = 0) OR (my_data = 10)), which evaluates TRUE for both 0 and 10.\n\n\"my_data IN (0, '1' || '0')\" works because || (concatenation) has a higher priority than = (equality comparison), and because Oracle will implicitly convert '10' to a NUMBER. So this one is equivalent to \"my_data IN (0, 10)\".\n\n\n\"my_data BETWEEN 10 AND 0\" does not work because the expression reduces to (my_data >= 10 AND my_data <= 0), which is never evaluated to TRUE. It is important to always place the smaller number first in a BETWEEN statement.\n\n","id":180},
{"explanation":"\"my_data BETWEEN 1 AND 0\" always returns 0 rows because the expression reduces to (my_data >= 1 AND my_data <= 0), which is never evaluated to TRUE. It is important to always place the smaller number first in a BETWEEN statement.\n\n","id":181},
{"explanation":"For a row to be accepted by a WHERE clause, the WHERE expression must evaluate to TRUE.\n\n<anything> = NULL always evaluates to UNKNOWN, so no rows will ever be returned by this select statement.","id":182},
{"explanation":"After the INSERT statements, my_table has the following data in it:\n\n[0]\n[NULL]\n\nFor a row to be accepted by a WHERE clause, the WHERE expression must evaluate to TRUE.\n\n0 IS NULL evaluates to FALSE.\nNULL IS NULL evaluates to TRUE.\n\nSo one record, the NULL record, is returned.\n","id":183},
{"explanation":"For a row to be accepted by a WHERE clause, the WHERE expression must evaluate to TRUE. \n\n<anything> != NULL always evaluates to UNKNOWN, so this select statement will never return anything.","id":184},
{"explanation":"After the INSERT statements, my_table has the following data in it:\n\n[0]\n[NULL]\n\nFor a row to be accepted by a WHERE clause, the WHERE expression must evaluate to TRUE.\n\n0 IS NOT NULL evaluates to TRUE.\nNULL IS NOT NULL evaluates to FALSE.\n\nSo one record, the 0 record, is returned by the query.","id":185},
{"explanation":"After the INSERT statements, my_table has the following data in it:\n\n[0]\n[NULL]\n\nFor a row to be accepted by a WHERE clause, the WHERE expression must evaluate to TRUE.\n\nmy_data NOT IN (0) reduces to the logical expression (my_data != 0).\n\n0 != 0 evaluates to FALSE.\nNULL != 0 evaluates to UNKNOWN.\n\nBecause no records evaluated to TRUE, no records are returned.","id":186},
{"explanation":"After the INSERT statements, my_table has the following data in it:\n\n[1]\n[NULL]\n\n&myVar substitutes for 1 due to the DEFINE statement at the top of the code. So the WHERE clause becomes (my_data = 1), which is matched with one record in my_table.","id":187},
{"explanation":"First, the DEFINE statement sets myVar = \"NOT\". However, myVar is removed due to the UNDEFINE statement.\n\nUNDEFINED variables always equate to an empty string, so the WHERE clause becomes :\n\nWHERE my_data = 1;\n\nWhich is matched to by the row inserted by the INSERT statement.","id":188},
{"explanation":"The SHOW command displays the value of a SQLcl system variable, or the current\nSQLcl environment. \n\nThe DEFINE command specifies a substitution variable and assigns a CHAR value to it, or\nlists the value and variable type of a single variable or all variables.\n\nThe DESCRIBE command lists the column definitions for a table, view, or synonym, or the specifications for a function or procedure.\n\nThere are no such SQL commands as VERIFY or DISPLAY.","id":189}.
{"explanation":"If you SET VERIFY, PL/SQL will print a message every time a DEFINED variable is substituted. \n\nDEFINE, ACCEPT, SHOW and PROMPT are all commands, not system variables.","id":190}

//spelling error on line 191
{"explanation":"PROMPT is a SQL command which sends the specified message or a blank line to the user's screen.\n\nVERIFY is a system variable which toggles whether or not PL/SQL will print a message every time a DEFINED variable is substituted. \n\nDEFINE specifies a substitution variable and assigns a CHAR value to it, or lists the value and variable type of a single variable or all variables.\n\nSHOW diaplays the value of a SQLcl system variable, or the current\nSQLcl environment. \n\nACCEPT reads a line of input and stores it in a given substitution variable.","id":191},
{"explanation":"ACCEPT reads a line of input and stores it in a given substitution variable.\n\nPROMPT is a SQL command which sends the specified message or a blank line to the user's screen.\n\nVERIFY is a system variable which toggles whether or not PL/SQL will print a message every time a DEFINED variable is substituted. \n\nDEFINE specifies a substitution variable and assigns a CHAR value to it, or lists the value and variable type of a single variable or all variables.\n\nSHOW diaplays the value of a SQLcl system variable, or the current\nSQLcl environment. ","id":192},
{"explanation":"The \"SET DEFINE *\" statement makes the '*' character the substitution variable identifier. The substitution identifier by default is the ampersand ('&') character. This means that after the \"DEFINE myVar = 1\" statement, the myVar substitution variable can be referenced as \"*myVar\" (whereas \"&myVar\" would be the default).\n\nTherefore, the instance of \"*myVar\" on the last line of the query will be substituted, causing the line to be \"WHERE my_data = 1;\", causing the query to return 1.\n\n","id":193},
{"explanation":"The \"SET DEFINE *\" statement makes the '*' character the substitution variable identifier. The substitution identifier by default is the ampersand ('&') character. This means that after the \"DEFINE myVar = 1\" statement, the myVar substitution variable can be referenced as \"*myVar\" (whereas \"&myVar\" would be the default).\n\nTherefore, the instance of \"&myVar\" on the last line of the query will not be substituted and will cause a syntax error.\n\n","id":194},
{"explanation":"The \"SET DEFINE OFF\" statement will turn off variable substitution. So even though myVar is defined as 1 in the first line, the last line will not substitute and therefore cause a syntax error.","id":195},
{"explanation":"The MOD function take in two mandatory parameters MOD(n2, n1) and returns the remainder of n2 divided by n1. Returns n2 if n1 is 0.\n\nSpecifically, the result of MOD(n2, n1) is calculated as:\n\n n2 - n1 * floor(n2/n1)\n\nThis differentiates MOD from the REMAINDER function, which uses the ROUND operation instead of the FLOOR operation its calculation.\n\nIn this example, MOD(8,3) is calculated as 8 - 3 * floor(8/3) = 8 - 3 * floor(2.66) = 8 - 3 * 2 = 8 - 6 = 2.","id":196},
{"explanation":"The REMAINDER function takes in two mandatory parameters REMAINDER(n2, n1) and returns the remainder of n2 divided by n1.\n\nSpecifically, the results of REMAINDER (n2, n1) are calculated as:\n\nn2 - n1 * round(n2/n1)\n\nThis differentiates REMAINDER from the MOD function, which uses the FLOOR operation instead of the ROUND operation.\n\nIn this example, REMAINDER(8,3) is calculated as 8 - 3 * round(8/3) = 8 - 3 * round(2.66) = 8 - 3 * 3 = 8 - 9 = -1.\n","id":197},
{"explanation":"The SOUNDEX function takes a string and serializes it into a code representing the phonetic representation of the sound of the string.\n\nYou don't need to memorize the exact SOUNDEX serialization logic, but you should know the basic steps of the algorithm:\n\n1) Retain the first letter of the string and remove all other occurrences of the following letters: a, e, h, i, o, u, w, y.\n\n2) Assign specific numbers to the remaining letters (after the first).\n\n\nIf we know these steps, the only possibly correct answer is O624.\n\n","id":198},
{"explanation":"The ADD_MONTHS(date, integer) function returns the supplied date plus the supplied integer number of months. The integer parameter can be negative, which results in a subtraction of months from date.\n\nLAG is an analytic function which, given a series of rows returned from a query and a position of the cursor, provides access to a row at a given physical offset PRIOR to that position.\n\nOFFSET is a keyword used in row-limiting clauses of a SELECT query.\n\nSUBTRACT_MONTHS is not an Oracle function.\n\nREDUCE is not an Oracle function.","id":199},
{"explanation":"The SUBSTR function extracts a substring from a string. It takes three mandatory parameters SUBSTR(string, startIndex, endIndex), where string is the string to extract the substring from, startIndex is the index of the first character of the desired substring, and endIndex is the index of the last character of the desired substring. Note that SUBSTR is not zero indexed, so the first character in the string is indexed as 1. An input of 0 for startIndex will be converted to 1.\n\nIn our example, we want the substring from 'Oracle' which starts at index 1 and ends at index 2. Because this function is 1-indexed, 'O' is the character mapped to index 1. The last character of our substring will be at index 2, which is 'r'. So our resulting substring is 'Or'.","id":200},

//error in 201: the answer isn't 'O', it's 'racle'
{"explanation":"The LTRIM(source_string, trim_string) function removes all instances of trim_string from the left of source_string.\n\nIn our example, LTRIM('Oracle', 'O') removes all instances of 'O' from the left of 'Oracle', leaving us with our answer 'racle'.","id":201},
{"explanation":"The LTRIM(source_string, trim_string) function removes all instances of trim_string from the left of source_string.\n\nIn our example, LTRIM('12345', '3') removes all instances of '3' from the left of '12345'. Because there are no instances of '3' on the leftmost side of '12345', no characters are trimmed.","id":202},

//add a question about LTRIM with the second parameter not included
//add questions about TRIM and RTRIM
{"explanation":"The TRUNC(n1, n2) function returns n1 with n2 digits after the decimal point. If n2 is omitted, it defaults to 0.\n\nIn our example, TRUNC(123.45) omits the n2 parameter, so it defaults to 0. Therefore we return 123.45 with 0 places after the decimal included, resulting in 123.","id":203},

//add questions about TRUNC with the second parameter and when the second parameter is negative
{"explanation":"The ROUND(n1, n2) returns n1 rounded to n2 places to the right of the decimal point. If you omit n2, then n1 is rounded to 0 places. \n\nIn our example, n1 = 123.45 and n2 = 1. So we round 123.45 to one decimal place, equaling 123.5","id":204},
{"explanation":"The SOUNDEX function takes a string and serializes it into a code representing the phonetic representation of the sound of the string.\n\nYou don't need to memorize the exact SOUNDEX serialization logic, but you should know the basic steps of the algorithm:\n\n1) Retain the first letter of the string and remove all other occurrences of the following letters: a, e, h, i, o, u, w, y.\n\n2) Assign specific numbers to the remaining letters (after the first).\n\nBased on these rules, none of the supplied answers could be correct.","id":205},
{"explanation":"The SOUNDEX function takes a string and serializes it into a code representing the phonetic representation of the sound of the string.\n\nYou don't need to memorize the exact SOUNDEX serialization logic, but you should know the basic steps of the algorithm:\n\n1) Retain the first letter of the string and remove all other occurrences of the following letters: a, e, h, i, o, u, w, y.\n\n2) Assign specific numbers to the remaining letters (after the first) which represent their sounds.\n\nIn our example, we use SOUNDEX on both sides of the equality condition, meaning that anything can be returned which is phonetically similar to 'Oracle'.","id":206},
{"explanation":"The MONTHS_BETWEEN(date1, date2) returns number of months between dates date1 and date2. The operation is non-commutative and functions similar to arithmetic subtraction: if date1 is later than date2, the answer is positive. If date2 is later than date1, then the answer is negative.\n\nIn our example, we are considering the months between 01/JAN/2017 and 01/DEC/2017. There are definitely exactly 11 months between the two dates, but because our second parameter is a later date than our first, the result is negative. So our answer is -11.","id":207},

//more MONTHS BETWEEN questions

{"explanation":"The LAST_DAY(date) function returns the last day of the month based on a date value.\n\nThe last day of any January month is the 31st, so LAST_DAY('01-JAN-17') is 31-JAN-17.","id":208},
{"explanation":"The INITCAP(char) function returns char, with the first letter of each word in uppercase, all other letters in lowercase. \n\nThe LPAD function returns an expression, left-padded to a specified length with specified characters.\n\nThe UPPER function returns a string in all uppercase.\n\nThe INSTR function returns the index of a substring inside of a string.\n\nHEAD is not an Oracle function","id":209},
{"explanation":"The INITCAP(char) function returns char, with the first letter of each word in uppercase, all other letters in lowercase. \n\nTherefore, INITCAP('oracle') returns 'Oracle'.","id":210},
{"explanation":"The LENGTH function returns the number of characters in a string.\n\nThe TRIM function removes leading or trailing characters from a character string.  \n\nThe INSTR function returns the index of a substring inside of a string.\n\nThe SOUNDEX function returns a serialization of a string representing how the characters phonetically sound like.\n\nSIZE is not an Oracle function.","id":211},
{"explanation":"The RPAD function appends, to the right of a string, specified characters a specified number of times.\n\nThe LPAD function appends, to the left of a string, specified characters a specified number of times.\n\nLAG is an analytic function which, given a series of rows returned from a query and a position of the cursor, provides access to a row at a given physical offset PRIOR to that position.\n\nThe TRIM function removes leading or trailing characters from a character string.  \n\nPAD is not an Oracle function.","id":212},
{"explanation":"The TRIM function removes leading or trailing characters from a character string.  \n\nThe RTRIM function removes trailing characters from a character string.  \n\nThe LTRIM function removes leading characters from a character string. \n\nThe INSTR function returns the index of a substring inside of a string.\n\nThe SOUNDEX function returns a serialization of a string representing how the characters phonetically sound like.","id":213}
{"explanation":"The INSTR function returns the index of a substring inside of a string.\n\nThe SUBSTR function extracts a substring from a string.\n\nThe REPLACE function replaces a set of characters inside a string with another set of characters.\n\nOFFSET is a keyword used in row-limiting clauses of a SELECT query.\n\nINDEXOF is not an Oracle function.","id":214},
{"explanation":"The SUBSTR function extracts a substring from a larger string.\n\nThe INSTR function returns the index of a substring inside of a string.\n\nThe REPLACE function replaces a set of characters inside a string with another set of characters.\n\nOFFSET is a keyword used in row-limiting clauses of a SELECT query.\n\nINDEXOF is not an Oracle function.","id":215},
{"explanation":"The REPLACE function replaces a set of characters inside a string with another set of characters.\n\nThe SUBSTR function extracts a substring from a larger string.\n\nThe INSTR function returns the index of a substring inside of a string.\n\nOFFSET is a keyword used in row-limiting clauses of a SELECT query.\n\nINDEXOF is not an Oracle function.","id":216},
{"explanation":"The SOUNDEX function returns a serialization of a string representing how the characters phonetically sound like.\n\nThe INSTR function returns the index of a substring inside of a string.\n\nThe SIGN function returns a value indicating the sign of a number.\n\nOFFSET is a keyword used in row-limiting clauses of a SELECT query.\n\nINDEXOF is not an Oracle function.","id":217},
{"explanation":"The ABS function returns the absolute value of a number.\n\nThe SIGN function returns a value indicating the sign of a number.\n\nMAG, ABV and MAGNITUDE are not real Oracle functions.","id":218},
{"explanation":"The SIGN function returns a value indicating the sign of a number.\n\nThe ABS function returns the absolute value of a number.\n\nThe TRUNC returns a number or date with a value truncated to a certain precision.\n\nMAG and PARITY are not real Oracle functions.","id":219},

//error in 220: no indictation that ABBR actually exists

{"explanation":"The UPPER function returns a string in all uppercase.\n\nThe INITCAP function returns a string with the first letter of each word in uppercase, all other letters in lowercase. \n\nUPCASE, CAPITALIZE and TO_UPPER are all not real Oracle functions.","id":221},,
{"explanation":"The LOWER function returns a string in all lowercase.\n\nTO_LOWER, DECAPTIALIZE, INITDECAP, and DOWNCASE are all not real Oracle functions.","id":222},
{"explanation":"After the INSERT statements, my_table has the following data in it:\n\n['my_data', 1]\n['MY_DATA', 2]\n\nThe UPPER function returns a string in all uppercase. Therefore UPPER('my_data') evaluates to 'MY_DATA', and the WHERE clause becomes\n\nWHERE my_column = 'MY_DATA'\n\nWhich is true for only one of the rows in my_table.","id":223},
{"explanation":"After the INSERT statements, my_table has the following data in it:\n\n['my_date', 1]\n['MY_DATA', 2]\n\nThe UPPER function returns a string in all uppercase. Therefore UPPER('my_data') evaluates to 'MY_DATA', and the WHERE clause becomes\n\nWHERE UPPER(my_column) = 'MY_DATA'\n\nConsider each of the rows in my_table:\n\nUPPER('my_data') evaluates to 'MY_DATA'.\nUPPER('MY_DATA') evaluates to 'MY_DATA'.\n\nBoth records pass the WHERE clause, so both are returned.","id":224},
{"explanation":"After the INSERT statements, my_table has the following data in it:\n\n['my_date', 1]\n['MY_DATA', 2]\n\nThe LOWER function returns a string in all lowercase. \n\nConsider each of the rows in my_table:\n\nLOWER('my_data') evaluates to 'my_data'.\nLOWER('MY_DATA') evaluates to 'my_data'.\n\nBoth records pass the WHERE clause, so both are returned.","id":225},
{"explanation":"After the INSERT statements, my_table has the following data in it:\n\n['My_data', 1]\n['MY_DATA', 2]\n\nThe INITCAP(char) function returns char, with the first letter of each word in uppercase, all other letters in lowercase.\n\nThe key to this question is that INITCAP delimits words by white space OR characters which are not alphanumeric. Because this, 'My_data' is delimited by '_' and is treated as two words instead of one.\n\nINITCAP('My_data') evaluates to 'My_Data'.\nINITCAP('MY_DATA') also evaluates to 'My_Data'.\n\nNeither record passes the WHERE clause, and as such neither are returned.","id":226},
{"explanation":"After the INSERT statements, my_table has the following data in it:\n\n['Mydata', 1]\n['MYDATA', 2]\n\nThe INITCAP(char) function returns char, with the first letter of each word in uppercase, all other letters in lowercase.\n\nINITCAP('Mydata') evaluates to 'Mydata'.\nINITCAP('MYDATA') also evaluates to 'Mydata'.\n\nBoth records pass the WHERE clause, and as such both are returned.","id":227},
{"explanation":"The INITCAP(char) function returns char, with the first letter of each word in uppercase, all other letters in lowercase.\n\nThe key to this question is that INITCAP delimits words by white space OR characters which are not alphanumeric. Because this, 'ellison''s' is delimited by ' and is treated as two words instead of one. \n\n'Ellison' and 'S' must be capitalized as they are treated as separate words, with an apostrophe between.\n\nNote that two apostrophes are required because one is needed as an escape character for the other to create a valid string.\n\n","id":228},
{"explanation":"The RPAD(s, n [, s2]) returns string s extended to the right or truncated to length n. The optional parameter s2 is the string which is appended to the right of s if it needs to be extended. If omitted, s2 defaults to a space.\n\nRPAD('my_text', 3, '.') returned 'my_text' truncated to length 3. The third parameter '.' is worthless because we are reducing the size of the string, not extending it.","id":229},
{"explanation":"The LPAD(s, n [, s2]) returns string s extended to the left or truncated to length n. The optional parameter s2 is the string which is appended to the left of s if it needs to be extended. If omitted, s2 defaults to a space.\n\nLPAD('txt', 5, '.') returns 'txt' extended to length 5 by appending '.' to the left. Therefore the result is '..txt'","id":230},
{"explanation":"The LTRIM(s1[, s2]) returns string s1 with all characters contained in s2 removed from the left side. s2 is optional and is replaced with a blankspace if omitted.\n\nLTRIM('...txt', '.') returns '...txt' with all '.' removed from the left side. Therefore, 'txt' is returned.","id":231},

//add a question regarding how LTRIM/RTRIM's second parameter is a set of characters instead of one character

{"explanation":"The RTRIM(s1[, s2]) returns string s1 with all characters contained in s2 removed from the right side. s2 is optional and is replaced with a blankspace if omitted.\n\nRTRIM('...txt', '.') returns '...txt' with all '.' removed from the right side. Because all of the '.' characters are on the LEFT side instead of the RIGHT, there are no characters removed and '...txt' is returned as-is.","id":232},
{"explanation":"TRIM(TRAILING s1 FROM s2) removes all occurrences of s1 from the right side of s2. \n\nTRIM( TRAILING '.' FROM '...txt') attempts to remove '.' from the right side of '...txt', but they are only on the left side, so the string remains unaltered.","id":233},
{"explanation":"TRIM(LEADING s1 FROM s2) removes all occurrences of s1 from the left side of s2. \n\nTRIM( LEADING '.' FROM '...txt') removes '.' from the left side of '...txt', so 'txt' is returned.","id":234}

//do a question for TRIM(BOTH)
//also a question trying to do TRIM( any s1 FROM s2) where s1 is more than one character. ORA-30001: trim set should have only one character is thrown.

{"explanation":"The INSTR(s1, s2[, n1, n2]) function returns the index of a substring s2 inside of a string s1. If s2 is not a substring of s1, then the function returns 0. n1 and n2 are optional parameters. n1 defines the index from which the search should begin. n2 defines which occurrence of the data will be searched for. Both n1 and n2 default to 1 if undefined.\n\nNote that INSTR is 1-indexed, not 0-indexed, so the index of the first character is 1.\n\n'my' is at the beginning of 'my_data' so INSTR('my_data', 'my') returns 1.","id":235},
{"explanation":"The INSTR(s1, s2[, n1, n2]) function returns the index of a substring s2 inside of a string s1. If s2 is not a substring of s1, then the function returns 0. n1 and n2 are optional parameters. n1 defines the index from which the search should begin. n2 defines which occurrence of the data will be searched for. Both n1 and n2 default to 1 if undefined.\n\nNote that INSTR is 1-indexed, not 0-indexed, so the index of the first character is 1.\n\nINSTR('data data', 'data', 1, 2) searches for the index of the 2nd occurrence of 'data' in 'data data', starting at index 1. The first occurrence is at index 1 and the second occurrence is at index 6, so 6 is returned.","id":236},
{"explanation":"The INSTR(s1, s2[, n1, n2]) function returns the index of a substring s2 inside of a string s1. If s2 is not a substring of s1, then the function returns 0. n1 and n2 are optional parameters. n1 defines the index from which the search should begin. n2 defines which occurrence of the data will be searched for. Both n1 and n2 default to 1 if undefined.\n\nNote that INSTR is 1-indexed, not 0-indexed, so the index of the first character is 1.\n\nINSTR('data data', 'data', 7, 2) searches for the index of the 2nd occurrence of 'data' in 'data data', starting at index 7. There are no occurrences after index 7 (The first occurrence is at index 1 and the second occurrence is at index 6) so 0 is returned.","id":237},
{"explanation":"The SUBSTR(s, n1[, n2]) function returns the substring of string s starting at index n1. n2 is an optional parameter and defines the length that the substring should be. If n2 is omitted, the entirety of string s starting at index n1 is returned.\n\nNote that SUBSTR is 1-indexed, not 0-indexed, so the index of the first character is 1.\n\nSUBSTR('my_data', 2) returns the substring of 'my_data' starting at index 2. So we return 'y_data'.","id":238},
{"explanation":"The SUBSTR(s, n1[, n2]) function returns the substring of string s starting at index n1. n2 is an optional parameter and defines the length that the substring should be. If n2 is omitted, the entirety of string s starting at index n1 is returned.\n\nNote that SUBSTR is 1-indexed, not 0-indexed, so the index of the first character is 1.\n\nSUBSTR('my_data', 1) returns the substring of 'my_data' starting at index 1. Index 1 is the first character, so 'my_data' is returned unaltered.","id":239},
{"explanation":"The SUBSTR(s, n1[, n2]) function returns the substring of string s starting at index n1. n2 is an optional parameter and defines the length that the substring should be. If n2 is omitted, the entirety of string s starting at index n1 is returned.\n\nNote that SUBSTR is 1-indexed, not 0-indexed, so the index of the first character is 1.\n\nThe key to this question is to know that if n1 = 0, then we start from the beginning of the string just as if n1 = 1. So SUBSTR('my_data', 0) returns the substring of 'my_data' starting at index 1. Index 1 is the first character, so 'my_data' is returned unaltered.","id":240},
{"explanation":"The SUBSTR(s, n1[, n2]) function returns the substring of string s starting at index n1. n2 is an optional parameter and defines the length that the substring should be. If n2 is omitted, the entirety of string s starting at index n1 is returned.\n\nNote that SUBSTR is 1-indexed, not 0-indexed, so the index of the first character is 1.\n\nSUBSTR('my_data', 100) returns the substring of 'my_data' starting at index 100. Because 'my_data' is only 7 characters long, SUBSTR returns an empty string, which is equivalent to NULL.","id":241},
{"explanation":"The CEIL(n) function returns the smallest integer greater than or equal to n.\n\nCIEL(1.2) evaluates to 2.","id":242},
{"explanation":"The FLOOR(n) function returns the largest integer less than or equal to n.\n\nFLOOR(1.2) evaluates to 1.","id":243},
{"explanation":"The ROUND(n1[, n2]) function returns n1 rounded to n2 places past the decimal. n2 is optional and if omitted defaults to 0.\n\nROUND(1.234, 2) returns 1.234 rounded to 2 decimal places. Therefore 1.23 is returned.","id":244},
{"explanation":"The ROUND(n1[, n2]) function returns n1 rounded to n2 places past the decimal. n2 is optional and if omitted defaults to 0.\n\nROUND(1.2345, 3) returns 1.2345 rounded to 3 decimal places. Therefore 1.235 is returned.","id":245},
{"explanation":"The ROUND(n1[, n2]) function returns n1 rounded to n2 places past the decimal. n2 is optional and if omitted defaults to 0.\n\nROUND(567.89, -1) returns 567.89 rounded to -1 places past the decimal -- meaning, it rounds to 1 place to the left of the decimal. Therefore, 570 is returned.","id":246},
{"explanation":"The TRUNC(n1[, n2]) function returns n1 \"truncated\" to n2 places past the decimal. In other words, all digits less significant than n2 places past the decimal are set to 0. n2 is optional and if omitted defaults to 0.\n\nTRUNC(123.456, 1) takes 123.456, saves all digits to 1 place past the decimal  and then sets all other digits to 0, equaling 123.400, or simply 123.4","id":247},
{"explanation":"The TRUNC(n1[, n2]) function returns n1 \"truncated\" to n2 places past the decimal. In other words, all digits less significant than n2 places past the decimal are set to 0. n2 is optional and if omitted defaults to 0.\n\nTRUNC(123.456, -1) takes 123.456, saves all digits to -1 place past the decimal (meaning 1 digit to the left of the decimal) and sets all less significant digits to 0. So 120.000 is returned, or simply 120.","id":248},
{"explanation":"The REMAINDER function takes in two mandatory parameters REMAINDER(n2, n1) and returns the remainder of n2 divided by n1. \n\nSpecifically, the results of REMAINDER (n2, n1) are calculated as: \n\nn2 - n1 * round(n2/n1) \n\nThis differentiates REMAINDER from the MOD function, which uses the FLOOR operation instead of the ROUND operation.\n\nSTD returns the standard deviation of a set of numbers.\n\nINTERVAL is not a function, but a keyword used in the instantiation of an INTERVAL data type literal.\n\nCLOSEST is not a real Oracle function.","id":249},
{"explanation":"The REMAINDER function takes in two mandatory parameters REMAINDER(n2, n1) and returns the remainder of n2 divided by n1. \n\nSpecifically, the results of REMAINDER (n2, n1) are calculated as: \n\nn2 - n1 * round(n2/n1) \n\nThis differentiates REMAINDER from the MOD function, which uses the FLOOR operation instead of the ROUND operation.\n\nREMAINDER(11, 4) evaluates as:\n\n11 - 4 * round(11/4) -> 11 - 4 * round(2.75) -> 11 - 4 * 3 -> 11 - 12 = -1.","id":250}
{"explanation":"The REMAINDER function takes in two mandatory parameters REMAINDER(n2, n1) and returns the remainder of n2 divided by n1. \n\nSpecifically, the results of REMAINDER (n2, n1) are calculated as: \n\nn2 - n1 * round(n2/n1) \n\nThis differentiates REMAINDER from the MOD function, which uses the FLOOR operation instead of the ROUND operation.\n\nREMAINDER(14, 4) evaluates as:\n\n14 - 4 * round(14/4) -> 14 - 4 * round(3.5) -> 14 - 4 * 4 -> 14 - 16 = -2.","id":251},
{"explanation":"The REMAINDER function takes in two mandatory parameters REMAINDER(n2, n1) and returns the remainder of n2 divided by n1. \n\nSpecifically, the results of REMAINDER (n2, n1) are calculated as: \n\nn2 - n1 * round(n2/n1) \n\nThis differentiates REMAINDER from the MOD function, which uses the FLOOR operation instead of the ROUND operation.\n\nREMAINDER(17, 5) evaluates as:\n\n17 - 5 * round(17/5) -> 17 - 5 * round(3.4) -> 17 - 5 * 3 -> 17 - 15 = 2.","id":252},
{"explanation":"The MOD function take in two mandatory parameters MOD(n2, n1) and returns the remainder of n2 divided by n1. Returns n2 if n1 is 0.\n\nSpecifically, the result of MOD(n2, n1) is calculated as:\n\nn2 - n1 * floor(n2/n1)\n\nThis differentiates MOD from the REMAINDER function, which uses the ROUND operation instead of the FLOOR operation its calculation.\n\nMOD(15, 1) evaluates as:\n\n15 - 1 * floor(15/1) -> 15 - 1 * floor(15) -> 15 - 1 * 15 = 15 - 15 = 0.","id":253},

// ask a question about what the result of LAST_DAY looks like

{"explanation":"SYSDATE returns the current date and time set for the operating system on which the database resides. \n\nCURRENT_DATE returns the current date in the local session time zone.\n\nTO_DATE is function which converts a data type to a DATE.\n\nLAST_DAY is a function which returns the last day of the month.\n\nORADATE is not an Oracle function.","id":254},
{"explanation":"The ROUND(date[, unit]) function rounds date to the nearest unit of time measurement. The unit parameter is optional and defaults to DAY.\n\nROUND(TO_DATE('30-DEC-2016'), 'MM') rounds 30-DEC-2016 to the nearest month. Because 30-DEC is more than halfway through the month, we round up to 01-JAN-2017.","id":255},
{"explanation":"The ROUND(date[, unit]) function rounds date to the nearest unit of time measurement. The unit parameter is optional and defaults to DAY.\n\nROUND(TO_DATE('15-DEC-2016'), 'MM') rounds 15-DEC-2016 to the nearest month. There are 31 days in December so 15-DEC represents less than half of the month. Therefore we round down to 01-DEC-2016.","id":256},
{"explanation":"The ROUND(date[, unit]) function rounds date to the nearest unit of time measurement. The unit parameter is optional and defaults to DAY.\n\nROUND(TO_DATE('14-DEC-2016'), 'MM') rounds 14-DEC-2016 to the nearest month. Because 14-DEC is less than halfway through the month, we round down to 01-DEC-2016. ","id":257},
{"explanation":"The ROUND(date[, unit]) function rounds date to the nearest unit of time measurement. The unit parameter is optional and defaults to DAY.\n\nROUND(TO_DATE('16-DEC-2016'), 'MM') rounds 16-DEC-2016 to the nearest month. Because 16-DEC is more than halfway through the month, we round up to 01-JAN-2017.","id":258},
{"explanation":"The ROUND(date[, unit]) function rounds date to the nearest unit of time measurement. The unit parameter is optional and defaults to DAY.\n\n'RR' is a unit for year. ROUND(TO_DATE('14-DEC-2016'), 'RR') rounds 16-DEC-2016 to the nearest year. Because 16-DEC is clearly more than halfway through the year, we round up to 01-JAN-2017.\n ","id":259},
{"explanation":"The ROUND(date[, unit]) function rounds date to the nearest unit of time measurement. The unit parameter is optional and defaults to DAY.\n\n'RR' is a unit for year. ROUND(TO_DATE('01-JAN-2017'), 'RR') rounds 01-JAN-2017 to the nearest year. Because 01-JAN is clearly less than halfway through the year, we round down to 01-JAN-2017.\n ","id":260}
{"explanation":"The TRUNC(date[, unit]) acts similarly to a FLOOR function. It returns the earliest possible date such that the unit of measurement defined by the 'unit' parameter stays the same.\n\n'RR' is a unit of measurement representing a YEAR. TRUNC(TO_DATE('30-DEC-2016'), 'RR') returns the earliest date that is still in 2016, which is 01-JAN-2016.","id":261},
{"explanation":"The TRUNC(date[, unit]) acts similarly to a FLOOR function. It returns the earliest possible date such that the unit of measurement defined by the 'unit' parameter stays the same.\n\n'MM' is a unit of measurement representing a MONTH. TRUNC(TO_DATE('30-DEC-2016'), 'RR') returns the earliest date that is still in December 2016, which is 01-DEC-2016.","id":262},

// add a question about TRUNC(date[, unit]) optional unit parameter

{"explanation":"The NEXT_DAY(date, weekday) function returns the first date which is greater than the passed in 'date' parameter and whose day of the week is the same as the passed in 'weekday' parameter.\n\nNEXT_DAY(TO_DATE('30-DEC-2016'), 'SATURDAY') returns the first day after 30-DEC-2016 which is a Saturday. Because 30-DEC-2017 is a Friday, this means that 31-DEC-2017 is the first Saturday after it, and is therefore the result.","id":263},
{"explanation":"The LAST_DAY(date) function returns the last day of the passed in 'date' parameter's month.\n\nLAST_DAY(TO_DATE('29-DEC-2016')) returns the last day of the month for December 2016. December has 31 days in it so the last day of the month is 31-DEC-2016.","id":264},
{"explanation":"The ADD_MONTHS(date, n) function returns the passed in 'date' , but n months later. Negative numbers can be passed in for n, which causes months to be subtracted from 'date' instead. If the resulting month would have fewer days than the day component of 'date', then the last day of that month is returned (such as if you were removing 1 month from 31-MARCH, 28-FEB would be returned.\n\nADD_MONTHS(TO_DATE('30-DEC-2016'), 1) returns '30-DEC-2016', but 1 month later. 1 month later than '30-DEC-2016' is '30-JAN-2017', which is the answer.\n\n","id":265},
{"explanation":"The ADD_MONTHS(date, n) function returns the passed in 'date' , but n months later. Negative numbers can be passed in for n, which causes months to be subtracted from 'date' instead. If the resulting month would have fewer days than the day component of 'date', then the last day of that month is returned (such as if you were removing 1 month from 31-MARCH, 28-FEB would be returned.\n\nADD_MONTHS(TO_DATE('30-DEC-2016'), -1) returns '30-DEC-2016', but 1 month earlier. 1 month earlier than '30-DEC-2016' is '30-NOV-2016', which is the answer.\n\n","id":266},
{"explanation":"The ADD_MONTHS(date, n) function returns the passed in 'date' , but n months later. Negative numbers can be passed in for n, which causes months to be subtracted from 'date' instead. If the resulting month would have fewer days than the day component of 'date', then the last day of that month is returned (such as if you were removing 1 month from 31-MARCH, 28-FEB would be returned.\n\nIf date is the last day of the month or if the resulting month has fewer days than the day component of date, then the result is the last day of the resulting month.\n\nADD_MONTHS(TO_DATE('31-DEC-2016'), -1) returns '31-DEC-2016', but 1 month earlier. 1 month earlier than '30-DEC-2016' might seem like '31-NOV-2016',  but because November only has 30 days, we return '30-NOV-2016'.","id":267},
{"explanation":"The MONTHS_BETWEEN(date1, date2) returns number of months between dates date1 and date2. The operation is non-commutative and functions similar to arithmetic subtraction: if date1 is later than date2, the answer is positive. If date2 is later than date1, then the answer is negative. If the number of months is not exact, a decimal number is returned.\n\nThere are 12 months between '31-DEC-2016' and '31-DEC-2017', so MONTHS_BETWEEN(TO_DATE('31-DEC-2016'), TO_DATE('31-DEC-2017')) would return 12, but because the first parameter is earlier than the second parameter, we return -12.","id":268},
{"explanation":"The MONTHS_BETWEEN(date1, date2) returns number of months between dates date1 and date2. The operation is non-commutative and functions similar to arithmetic subtraction: if date1 is later than date2, the answer is positive. If date2 is later than date1, then the answer is negative. If the number of months is not exact, a decimal number is returned.\n\nThere are 12 months between '31-DEC-2016' and '31-DEC-2017', so MONTHS_BETWEEN(TO_DATE('31-DEC-2016'), TO_DATE('31-DEC-2017')) would return 12. Because the first parameter is later than the second parameter, we do return 12. If '31-DEC-2017' had been the first parameter, and '31-DEC-2016' been the second parameter, the answer would have been negative (-12).","id":269},
{"explanation":"The ROUND(n1, n2) returns n1 rounded to n2 places to the right of the decimal point.\n\nThe MONTHS_BETWEEN(date1, date2) returns number of months between dates date1 and date2. The operation is non-commutative and functions similar to arithmetic subtraction: if date1 is later than date2, the answer is positive. If date2 is later than date1, then the answer is negative. If the number of months is not exact, a decimal number is returned.\n\nIn MONTHS_BETWEEN(TO_DATE('30-NOV-2017'), TO_DATE('15-NOV-2017')), there is about half a month between the two date parameters. It is not exactly 0.5; it is somewhere around 0.484. Because the later date was the first parameter, the result is positive. \n\nSo our nested function becomes ROUND(0.484, 1), which results to 0.484 rounding to the first decimal place -- evaluating to 0.5.","id":270},
{"explanation":"The NUMTOYMINTERVAL(n, unit) returns a YEAR TO MONTH INTERVAL data type whose value is n number of the specified measurement unit. 'unit' can either be YEAR or MONTH.\n\nNUMTOYMINTERVAL(13, 'MONTH') returns a YEAR TO MONTH INTERVAL data type whose value is 13 months. 13 months is 1 Year and 1 Month, so our result is 1-1.","id":271},
{"explanation":"The NUMTOYMINTERVAL(n, unit) returns a YEAR TO MONTH INTERVAL data type whose value is n number of the specified measurement unit. 'unit' can either be YEAR or MONTH.\n\nNUMTOYMINTERVAL(13, 'YEAR') returns a YEAR TO MONTH INTERVAL data type whose value is 13 years. Therefore our result reflects 13 years and 0 months, or 13-0.","id":272},
{"explanation":"After the INSERT statements, my_table has the following data in it:\n\n[1, 1]\n[2, 2]\n[3, 3]\n[4, 4]\n[5, 5]\n\nThe SUM(my_data) OVER(ORDER BY id) analytical function will keep a running total of the of the my_data across rows as we iterate through them. The ORDER BY id clause simply tells us iterate through the rows after sorting by id.\n\n\nBecause our data set is already sorted by id in ascending order, we don't have to worry about it.\n\nNote that the ANALYTICS column is just keeping track of the running SUM(my_num) as we reverse through the data set.\n\n[1, 1] -> ANALYTICS = 1\n[2, 2] -> ANALYTICS += 2 = 3\n[3, 3] -> ANALYTICS += 3 = 6\n[4, 4] -> ANALYTICS += 4 = 10\n[5, 5] -> ANALYTICS += 5 = 15\n\n\nSo our subquery \n\nSELECT ROWNUM as MY_ROW,\nSUM(my_data) OVER (ORDER BY id) as ANALYTICS\nFROM my_table\n\nwill return the following data:\n\n------------------\n|MY_ROW|ANALYTICS|\n------------------\n|   1  |    1    |\n|   2  |    3    |\n|   3  |    6    |\n|   4  |    10   |\n|   5  |    15   |\n------------------\n\nOur outer query returns ANALYTICS from the row where MY_ROW = 4, so 10 is returned.\n","id":273},
{"explanation":"This is a question about analytical functions. Analytical functions aggregate data across rows as you iterate through them. As opposed to aggregate functions, which return one row of aggregated data for the group of rows they operate on, analytic functions return multiple rows of aggregated data for the group of rows they operate on. \n\nThe function we are concerned with in this question is:\n\nSUM(my_data) OVER (ORDER BY id\nROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING)\n\nSUM(my_data) will return a running total of the sum of my_data as we iterate through the rows.\n\nOVER(... BETWEEN 1 PRECEDING AND 1 FOLLOWING) indicates that our SUM(my_data) will only operate on the current row, the previous row and the next row.\n\nOVER (ORDER BY id... ) indicates that we are iterating through the rows by order of the id column.\n\nSo our analytical function will iterate through the data set by id ascending and return the SUM(my_data) for the current row, the previous row and the next row.\n\nAfter the INSERT statements, my_table has the following data in it:\n\n[1, 1]\n[2, 2]\n[3, 3]\n[4, 4]\n[5, 5]\n\nBecause our data set is already sorted by id in ascending order, we don't have to worry about it.\n\nThe ANALYTICS row will be calculated as follows:\n\n[1, 1] -> ANALYTICS = 1 + 2 = 3\n[2, 2] -> ANALYTICS = 1 + 2 + 3 = 6\n[3, 3] -> ANALYTICS = 2 + 3 + 4 = 9\n[4, 4] -> ANALYTICS = 3 + 4 + 5 = 12\n[5, 5] -> ANALYTICS = 4 + 5 = 9\n\nSo our subquery will return the following data:\n\n------------------\n|MY_ROW|ANALYTICS|\n------------------\n|   1  |    3    |\n|   2  |    6    |\n|   3  |    9    |\n|   4  |   12    |\n|   5  |    9    |\n------------------\n\n\nOur outer query returns ANALYTICS from the row where MY_ROW = 5, so 9 is returned.\n\n\n\n\n","id":274},
{"explanation":"This is a question about analytical functions. Analytical functions aggregate data across rows as you iterate through them. As opposed to aggregate functions, which return one row of aggregated data for the group of rows they operate on, analytic functions return multiple rows of aggregated data for the group of rows they operate on. \n\nThe function we are concerned with in this question is:\n\nSUM(my_data) OVER (PARTITION BY ID\nORDER BY id \nROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING)\n\nSUM(my_data) will return a running total of the sum of my_data as we iterate through the rows.\n\n\nOVER (... PARTITION BY ID.. ) indicates that we will group our rows by ID. That means rows with different values in their ID column will be operated on separately.\n\nOVER(... BETWEEN 1 PRECEDING AND 1 FOLLOWING) indicates that our SUM(my_data) will only operate on the current row, the previous row and the next row.\n\nOVER (... ORDER BY id... ) indicates that we are iterating through the rows by order of the id column.\n\nSo our analytical function will group the rows by ID, iterate through the data sets by id ascending and return the SUM(my_data) for the current row, the previous row and the next row.\n\nAfter the INSERT statements, my_table has the following data in it:\n\n[1, 1]\n[2, 2]\n[3, 1]\n[4, 2]\n[5, 1]\n\n\nFirst, we group the data by ID:\n\n[1, 1]\n[3, 1]\n[5, 1]\n\n[4, 2]\n[2, 2]\n\n\nBecause our data set is grouped by id, we will not have rows with different id values operated on together. so the ORDER BY id clause does nothing.\n\nThe ANALYTICS row will be calculated as follows:\n\n[1, 1] -> ANALYTICS = 1 + 3 = 5\n[3, 1] -> ANALYTICS = 1 + 3 + 5 = 9\n[5, 1] -> ANALYTICS = 3 + 5 = 8\n\n[4, 2] -> ANALYTICS = 4 + 2 = 6\n[2, 2] -> ANALYTICS = 4 + 2 = 6\n\nNote that when returning the results, we retain the original insert order:\n\n[1, 1] -> ROWNUM = 1\n[2, 2] -> ROWNUM = 2\n[3, 1] -> ROWNUM = 3\n[4, 2] -> ROWNUM = 4\n[5, 1] -> ROWNUM = 5\n\nSo our subquery will return the following data:\n\n------------------\n|MY_ROW|ANALYTICS|\n------------------\n|   1  |    5    | \n|   2  |    6    |\n|   3  |    9    |\n|   4  |    6    |\n|   5  |    8    |\n------------------\n\n\nOur outer query returns ANALYTICS from the row where MY_ROW = 3, so 9 is returned.\n\n\n\n\n","id":275},
{"explanation":"This is a question about analytical functions. Analytical functions aggregate data across rows as you iterate through them. As opposed to aggregate functions, which return one row of aggregated data for the group of rows they operate on, analytic functions return multiple rows of aggregated data for the group of rows they operate on. \n\nThe function we are concerned with in this question is:\n\nLAG(my_data) OVER (PARTITION BY ID ORDER BY id)\n\nLAG(my_data) will return the value of the previous row's my_data column.\n\nOVER (... PARTITION BY ID.. ) indicates that we will group our rows by ID. That means rows with different values in their ID column will be operated on separately.\n\nOVER (... ORDER BY id) indicates that we are iterating through the rows by order of the id column.\n\nSo our analytical function will group the rows by ID, iterate through the data sets by id ascending and return the my_data value for the previous row.\n\nAfter the INSERT statements, my_table has the following data in it:\n\n[1, 1]\n[2, 2]\n[3, 1]\n[4, 2]\n[5, 1]\n\n\nFirst, we group the data by ID due to the PARTITION clause:\n\n[1, 1]\n[3, 1]\n[5, 1]\n\n[4, 2]\n[2, 2]\n\n\nBecause our data set is grouped by id, we will not have rows with different id values operated on together. So the ORDER BY id clause does nothing.\n\nThe ANALYTICS row will be calculated as follows:\n\n[1, 1] -> ANALYTICS = NULL\n[3, 1] -> ANALYTICS = 1\n[5, 1] -> ANALYTICS = 3\n\n[4, 2] -> ANALYTICS = NULL\n[2, 2] -> ANALYTICS = 4\n\nNote that when returning the results, we retain the original insert order:\n\n[1, 1] -> ROWNUM = 1\n[2, 2] -> ROWNUM = 2\n[3, 1] -> ROWNUM = 3\n[4, 2] -> ROWNUM = 4\n[5, 1] -> ROWNUM = 5\n\nSo our subquery will return the following data:\n\n------------------\n|MY_ROW|ANALYTICS|\n------------------\n|   1  |   NULL  | \n|   2  |    4    |\n|   3  |    1    |\n|   4  |   NULL  |\n|   5  |    3    |\n------------------\n\n\nOur outer query returns ANALYTICS from the row where MY_ROW = 2, so 4 is returned.\n\n\n\n\n","id":276},
{"explanation":"This is a question about analytical functions. Analytical functions aggregate data across rows as you iterate through them. As opposed to aggregate functions, which return one row of aggregated data for the group of rows they operate on, analytic functions return multiple rows of aggregated data for the group of rows they operate on. \n\nThe function we are concerned with in this question is:\n\nLEAD(my_data) OVER (PARTITION BY ID ORDER BY id)\n\nLEAD(my_data) will return the value of the next row's my_data column.\n\nOVER (... PARTITION BY ID.. ) indicates that we will group our rows by ID. That means rows with different values in their ID column will be operated on separately.\n\nOVER (... ORDER BY id) indicates that we are iterating through the rows by order of the id column.\n\nSo our analytical function will group the rows by ID, iterate through the data sets by id ascending and return the my_data value for the next row.\n\nAfter the INSERT statements, my_table has the following data in it:\n\n[1, 1]\n[2, 2]\n[3, 1]\n[4, 2]\n[5, 1]\n\n\nFirst, we group the data by ID due to the PARTITION clause:\n\n[1, 1]\n[3, 1]\n[5, 1]\n\n[4, 2]\n[2, 2]\n\n\nBecause our data set is grouped by id, we will not have rows with different id values operated on together. So the ORDER BY id clause does nothing.\n\nThe ANALYTICS row will be calculated as follows:\n\n[1, 1] -> ANALYTICS = 3\n[3, 1] -> ANALYTICS = 5\n[5, 1] -> ANALYTICS = NULL\n\n[4, 2] -> ANALYTICS = 2\n[2, 2] -> ANALYTICS = NULL\n\nNote that when returning the results, we retain the original insert order:\n\n[1, 1] -> ROWNUM = 1\n[2, 2] -> ROWNUM = 2\n[3, 1] -> ROWNUM = 3\n[4, 2] -> ROWNUM = 4\n[5, 1] -> ROWNUM = 5\n\nSo our subquery will return the following data:\n\n------------------\n|MY_ROW|ANALYTICS|\n------------------\n|   1  |    3    | \n|   2  |  NULL   |\n|   3  |    5    |\n|   4  |    2    |\n|   5  |  NULL   |\n------------------\n\n\nOur outer query returns ANALYTICS from the row where MY_ROW = 3, so 5 is returned.\n\n\n\n\n","id":277},
{"explanation":"The LAG analytic function returns a value from the previous row.\n\nThe LEAD analytic function returns a value from the next row.\n\nThe SUM analytic function keeps a running total of the SUM of a column as you iterate through the rows the function is operating on.\n\nOVER and PARTITION are keywords used in analytic functions to specify the group of rows that the function will operate on.","id":278}, 
{"explanation":"The LEAD analytic function returns a value from the next row.\n\nThe LAG analytic function returns a value from the previous row.\n\nThe SUM analytic function keeps a running total of the SUM of a column as you iterate through the rows the function is operating on.\n\nOVER and PARTITION are keywords used in analytic functions to specify the group of rows that the function will operate on.","id":279}, 
//280 is completetely wrong. A != relationship counts as a nonequijoin. Fix and edit the below explanation
//{"explanation":"A Non-Equijoin is a join which matches columns from different tables based on relational operators other than equality or nonequality.\n\n<= would match columns based on a \"greater than or equal to\" relationship. This is not an equality relationship so it would be considered a non-equijoin.\n\n= matches columns that are equal, so it would be used in an equijoin rather than a non-equijoin.\n\n!= and <> match columns that are not equal, so it would be used in an equijoin rather than a non-equijoin.","id":280},
{"explanation":"Oracle JOINS and INNER JOINS are functionally equivalent so the INNER keyword is optional.\n\nRemoving JOIN, FROM, ON or SELECT would throw a syntax error.","id":281},

// lots more questions on join types, including comma joins
{"explanation":"A JOIN ... USING(column_names) clause is an INNER JOIN on the supplied columns. The USING clause will be transformed to an ON clause that checks for equality between the named columns in the two tables. The columns listed in the USING clause must be present in both of the two tables being joined. \n\nIn our example, we have an INNER JOIN between my_table_1 and my_table_2 on the my_data column. This means that we return the records where my_table_1.my_data = my_table_2.my_data\n\nBecause we inserted '1' into both tables, then they have a matching value in my_table which is returned. Note that if my_table_1 and my_table_2 did not both have a column named 'my_data', the execution would have failed.","id":282},
{"explanation":"A JOIN ... USING(column_names) clause is an INNER JOIN on the supplied columns. The USING clause will be transformed to an ON clause that checks for equality between the named columns in the two tables. The columns listed in the USING clause must be present in both of the two tables being joined. \n\nIn our example, we have an INNER JOIN between my_table_1 and my_table_2 on the my_data column. This means that we return the records where my_table_1.my_data = my_table_2.my_data\n\nHowever, the execution fails because my_data2 is ambiguously defined. Both my_table_1 and my_table_2 have an available column named my_data2, so the compiler does not know which one to return and throws an error.\n\nIf my_data2 had been included in the USING clause, or had been qualified in the select list (e.g. my_table_1.my_data2), then there would not have been an execution failure.","id":283},
{"explanation":"Oracle table aliases are temporary names for table. They are defined inline inside of a query and are only valid in the scope of that query. They are typically used to clarify table references so that entire table names do not have to be retyped.\n\nTable aliases are temporary and do not rename the table.\n\nThey are not database objects; they only  exist as syntactical conveniences and are translated at compile time.\n\nSYNONYMS are schema objects which provide alternate names for other database objects across any query.\n","id":284},
{"explanation":"A JOIN ... USING(column_names) clause is an INNER JOIN on the supplied columns. The USING clause will be transformed to an ON clause that checks for equality between the named columns in the two tables.\n\nBecause the join checks for equality, it is an equijoin.","id":285},

//remove the NATURAL JOIN option from 286
//remove the NATURAL JOIN option from 287 and change the OUTER option to FULL OUTER


{"explanation":"An INNER JOIN returns rows from the joined tables where the join condition is met by both tables.\n\nA LEFT JOIN returns all rows from the table on the left side of the join and only the rows from the table on the right side which satisfy the join condition. Unavailable data from the table on the right side is filled in by NULLS.\n\nAn OUTER JOIN is any join which allows at least one table to be exempt from meeting the join condition.\n\nA CROSS JOIN returns the Cartesian product of the joined tables, meaning that it returns all combinations of all rows in one table joined with all rows in the other. ","id":286},
{"explanation":"A FULL OUTER JOIN connects rows as long as they exist in at least one of the joined tables.\n\nAn INNER JOIN returns rows from the joined tables where the join condition is met by both tables.\n\nA LEFT JOIN returns all rows from the table on the left side of the join and only the rows from the table on the right side which satisfy the join condition. Unavailable data from the table on the right side is filled in by NULLS.\n\nA CROSS JOIN returns the Cartesian product of the joined tables, meaning that it returns all combinations of all rows in one table joined with all rows in the other. ","id":287},
{"explanation":"An equijoin is a join which connects on an exact equality relationship (e.g. column_1 = column_2).\n\nAn nonequijoin is a join which does not connect on an exact equality relationship.\n\nThere is no such thing as a Cartesian join, but a CROSS JOIN returns the Cartesian product of the joined tables.","id":288},
{"explanation":"An nonequijoin is a join which does not connect on an exact equality relationship but rather on inequality relationships.\n\nAn equijoin is a join which connects on an exact equality relationship (e.g. column_1 = column_2).\n\nThere is no such thing as a Cartesian join, but a CROSS JOIN returns the Cartesian product of the joined tables.","id":289},
{"explanation":"An INNER JOIN returns rows from the joined tables where the join condition is met by both tables.\n\nAfter the INSERT statements, my_table_1 has the following data in it:\n\n---------\n|MY_DATA|\n---------\n|   1   |\n|   2   |\n---------\n\nand my_table_2 has the following data in it:\n\n---------\n|MY_DATA|\n---------\n|   1   |\n|   4   |\n---------\n\nOur join is:\n\nmy_table_1 a INNER JOIN my_table_2 b ON a.my_data = b.my_data\n\nNote that the join produces a rowset that has two columns: MY_DATA, which represents my_table_1.my_data, and MY_DATA_1, which represents my_table_2.my_data (the _1 is added at the end automatically by Oracle to prevent column ambiguity).\n\nWe return the rows where my_data is the same value in both my_table_1 and my_table_2. Both tables have a row with [1] in it, so this join produces the following result set:\n\n\n-------------------\n|MY_DATA|MY_DATA_1|\n-------------------\n|   1   |    1    | \n-------------------\n\n\nSince one row is returned, COUNT(*) = 1, which is our result.\n","id":290},
{"explanation":"A JOIN is functionally equivalent to an INNER JOIN and returns rows from the joined tables where the join condition is met by both tables.\n\nAfter the INSERT statements, my_table_1 has the following data in it:\n\n---------\n|MY_DATA|\n---------\n|   1   |\n|   2   |\n---------\n\nand my_table_2 has the following data in it:\n\n---------\n|MY_DATA|\n---------\n|   1   |\n|   4   |\n---------\n\nOur join is:\n\nmy_table_1 a JOIN my_table_2 b ON a.my_data = b.my_data\n\nNote that the join produces a rowset that has two columns: MY_DATA, which represents my_table_1.my_data, and MY_DATA_1, which represents my_table_2.my_data (the _1 is added at the end automatically by Oracle to prevent column ambiguity).\n\nWe return the rows where my_data is the same value in both my_table_1 and my_table_2. Both tables have a row with [1] in it, so this join produces the following result set:\n\n\n-------------------\n|MY_DATA|MY_DATA_1|\n-------------------\n|   1   |    1    | \n-------------------\n\n\nSince one row is returned, COUNT(*) = 1, which is our result.\n","id":291},
{"explanation":"A LEFT JOIN returns all rows from the table on the left side of the join and only the rows from the table on the right side which satisfy the join condition. Unavailable data from the table on the right side is filled in by NULLS.\n\nAfter the INSERT statements, my_table_1 has the following data in it:\n\n---------\n|MY_DATA|\n---------\n|   1   |\n|   2   |\n---------\n\nand my_table_2 has the following data in it:\n\n---------\n|MY_DATA|\n---------\n|   1   |\n|   4   |\n---------\n\nOur join is:\n\nmy_table_1 a LEFT JOIN my_table_2 b ON a.my_data = b.my_data\n\nNote that the join produces a rowset that has two columns: MY_DATA, which represents my_table_1.my_data, and MY_DATA_1, which represents my_table_2.my_data (the _1 is added at the end automatically by Oracle to prevent column ambiguity).\n\nWe return all rows in my_table_1 in the MY_DATA column and return only the values from my_table_2.my_data which exist in my_table_1. There is only one value in common, which is [1]. So our result looks like this:\n \n-------------------\n|MY_DATA|MY_DATA_1|\n-------------------\n|   1   |    1    | \n|   2   |   NULL  | \n-------------------\n\n\nSince two rows are returned, COUNT(*) = 2, which is our result.\n","id":292},
{"explanation":"A LEFT OUTER JOIN is equivalent to a LEFT JOIN and returns all rows from the table on the left side of the join and only the rows from the table on the right side which satisfy the join condition. Unavailable data from the table on the right side is filled in by NULLS.\n\nAfter the INSERT statements, my_table_1 has the following data in it:\n\n---------\n|MY_DATA|\n---------\n|   1   |\n|   2   |\n---------\n\nand my_table_2 has the following data in it:\n\n---------\n|MY_DATA|\n---------\n|   1   |\n|   4   |\n---------\n\nOur join is:\n\nmy_table_1 a LEFT OUTER JOIN my_table_2 b ON a.my_data = b.my_data\n\nNote that the join produces a rowset that has two columns: MY_DATA, which represents my_table_1.my_data, and MY_DATA_1, which represents my_table_2.my_data (the _1 is added at the end automatically by Oracle to prevent column ambiguity).\n\nWe return all rows in my_table_1 in the MY_DATA column and return only the values from my_table_2.my_data which exist in my_table_1 in the MY_DATA_1 column. There is only one value in common, which is [1]. So our result looks like this:\n \n-------------------\n|MY_DATA|MY_DATA_1|\n-------------------\n|   1   |    1    | \n|   2   |   NULL  | \n-------------------\n\n\nSince two rows are returned, COUNT(*) = 2, which is our result.\n","id":293},
{"explanation":"A RIGHT JOIN returns all rows from the table on the right side of the join and only the rows from the table on the left side which satisfy the join condition. Unavailable data from the table on the left side is filled in by NULLS.\n\nAfter the INSERT statements, my_table_1 has the following data in it:\n\n---------\n|MY_DATA|\n---------\n|   1   |\n|   2   |\n---------\n\nand my_table_2 has the following data in it:\n\n---------\n|MY_DATA|\n---------\n|   1   |\n|   4   |\n---------\n\nOur join is:\n\nmy_table_1 a RIGHT JOIN my_table_2 b ON a.my_data = b.my_data\n\nNote that the join produces a rowset that has two columns: MY_DATA, which represents my_table_1.my_data, and MY_DATA_1, which represents my_table_2.my_data (the _1 is added at the end automatically by Oracle to prevent column ambiguity).\n\nWe return all rows in my_table_2 in the MY_DATA_1 column and return only the values from my_table_1.my_data which exist in my_table_2 in the MY_DATA column. There is only one value in common, which is [1]. So our result looks like this:\n \n-------------------\n|MY_DATA|MY_DATA_1|\n-------------------\n|   1   |    1    | \n|  NULL |    4    | \n-------------------\n\n\nSince two rows are returned, COUNT(*) = 2, which is our result.\n","id":294},
{"explanation":"A RIGHT JOIN returns all rows from the table on the right side of the join and only the rows from the table on the left side which satisfy the join condition. Unavailable data from the table on the left side is filled in by NULLS.\n\nAfter the INSERT statements, my_table_1 has the following data in it:\n\n---------\n|MY_DATA|\n---------\n|   1   |\n|   2   |\n---------\n\nand my_table_2 has the following data in it:\n\n---------\n|MY_DATA|\n---------\n|   1   |\n|   3   |\n|   4   |\n---------\n\nOur join is:\n\nmy_table_1 a RIGHT JOIN my_table_2 b ON a.my_data = b.my_data\n\nNote that the join produces a rowset that has two columns: MY_DATA, which represents my_table_1.my_data, and MY_DATA_1, which represents my_table_2.my_data (the _1 is added at the end automatically by Oracle to prevent column ambiguity).\n\nWe return all rows in my_table_2 in the MY_DATA_1 column and return only the values from my_table_1.my_data which exist in my_table_2 in the MY_DATA column. There is only one value in common, which is [1]. So our result looks like this:\n \n-------------------\n|MY_DATA|MY_DATA_1|\n-------------------\n|   1   |    1    | \n|  NULL |    3    | \n|  NULL |    4    | \n-------------------\n\n\nSince three rows are returned, COUNT(*) = 3, which is our result.\n","id":295},
{"explanation":"A RIGHT JOIN returns all rows from the table on the right side of the join and only the rows from the table on the left side which satisfy the join condition. Unavailable data from the table on the left side is filled in by NULLS.\n\nAfter the INSERT statements, my_table_1 has the following data in it:\n\n---------\n|MY_DATA|\n---------\n|   1   |\n|   2   |\n---------\n\nand my_table_2 has the following data in it:\n\n---------\n|MY_DATA|\n---------\n|   1   |\n|   3   |\n|   1   |\n---------\n\nOur join is:\n\nmy_table_1 a RIGHT JOIN my_table_2 b ON a.my_data = b.my_data\n\nNote that the join produces a rowset that has two columns: MY_DATA, which represents my_table_1.my_data, and MY_DATA_1, which represents my_table_2.my_data (the _1 is added at the end automatically by Oracle to prevent column ambiguity).\n\nWe return all rows in my_table_2 in the MY_DATA_1 column and return only the values from my_table_1.my_data which exist in my_table_2 in the MY_DATA column. Because there are two entries of [1] in my_table_2, the single entry of [1] in my_table_1 matches to both of them.\n\nSo our result looks like this:\n \n-------------------\n|MY_DATA|MY_DATA_1|\n-------------------\n|   1   |    1    | \n|  NULL |    3    | \n|   1   |    1    | \n-------------------\n\n\nSince three rows are returned, COUNT(*) = 3, which is our result.\n","id":296},
{"explanation":"The syntax SELECT... FROM <table_1>, <table_2>... indicates an implicit CROSS JOIN. A CROSS JOIN returns the Cartesian product of the joined tables, meaning that it returns all combinations of all rows in one table joined with all rows in the other. \n\nAfter the INSERT statements, my_table_1 has the following data in it:\n\n---------\n|MY_DATA|\n---------\n|   1   |\n|   2   |\n---------\n\nand my_table_2 has the following data in it:\n\n---------\n|MY_DATA|\n---------\n|   1   |\n|   4   |\n---------\n\nOur join can be interpreted like this:\n\nmy_table_1 a CROSS JOIN my_table_2 b\n\nNote that the join produces a rowset that has two columns: MY_DATA, which represents my_table_1.my_data, and MY_DATA_1, which represents my_table_2.my_data (the _1 is added at the end automatically by Oracle to prevent column ambiguity).\n\nWe return all rows from my_table_1, each matched to all rows of my_table_2. Therefore we return 2 x 2 = 4 records.\n\nSo our result looks like this:\n \n-------------------\n|MY_DATA|MY_DATA_1|\n-------------------\n|   1   |    1    | \n|   1   |    4    | \n|   2   |    1    | \n|   2   |    4    | \n-------------------\n\n\nSince four rows are returned, COUNT(*) = 4, which is our result.\n","id":297},
{"explanation":"A FULL OUTER JOIN connects rows as long as they exist in at least one of the joined tables.\n\nAfter the INSERT statements, my_table_1 has the following data in it:\n\n---------\n|MY_DATA|\n---------\n|   1   |\n|   2   |\n---------\n\nand my_table_2 has the following data in it:\n\n---------\n|MY_DATA|\n---------\n|   1   |\n|   4   |\n---------\n\nOur join can be interpreted like this:\n\nmy_table_1 a FULL OUTER JOIN my_table_2 b\n\nNote that the join produces a rowset that has two columns: MY_DATA, which represents my_table_1.my_data, and MY_DATA_1, which represents my_table_2.my_data (the _1 is added at the end automatically by Oracle to prevent column ambiguity).\n\nWe return all rows from my_table_1 and all rows from my_table_2, but connecting the rows where my_table_1.my_data = my_table_2.my_data, which only happens for [1] which is in both tables.\n\nSo our result looks like this:\n \n-------------------\n|MY_DATA|MY_DATA_1|\n-------------------\n|   1   |    1    | \n|  NULL |    4    | \n|   2   |   NULL  | \n-------------------\n\n\nSince three rows are returned, COUNT(*) = 3, which is our result.\n","id":298},

//299 is wrong; answer is 4 not 3
{"explanation":"A FULL OUTER JOIN connects rows as long as they exist in at least one of the joined tables.\n\nAfter the INSERT statements, my_table_1 has the following data in it:\n\n---------\n|MY_DATA|\n---------\n|   1   |\n|   2   |\n---------\n\nand my_table_2 has the following data in it:\n\n---------\n|MY_DATA|\n---------\n|   3   |\n|   4   |\n---------\n\nOur join can be interpreted like this:\n\nmy_table_1 a FULL OUTER JOIN my_table_2 b\n\nNote that the join produces a rowset that has two columns: MY_DATA, which represents my_table_1.my_data, and MY_DATA_1, which represents my_table_2.my_data (the _1 is added at the end automatically by Oracle to prevent column ambiguity).\n\nWe return all rows from my_table_1 and all rows from my_table_2, but connecting the rows where my_table_1.my_data = my_table_2.my_data, which never happens in our data set.\n\nSo our result looks like this:\n \n-------------------\n|MY_DATA|MY_DATA_1|\n-------------------\n|  NULL |    3    |\n|  NULL |    4    | \n|   1   |   NULL  | \n|   2   |   NULL  | \n-------------------\n\n\nSince four rows are returned, COUNT(*) = 4, which is our result.\n","id":299},

//300 is the same as 299 but with the correct answer. Maybe take out 299?
{"explanation":"A FULL OUTER JOIN connects rows as long as they exist in at least one of the joined tables.\n\nAfter the INSERT statements, my_table_1 has the following data in it:\n\n---------\n|MY_DATA|\n---------\n|   1   |\n|   2   |\n---------\n\nand my_table_2 has the following data in it:\n\n---------\n|MY_DATA|\n---------\n|   3   |\n|   4   |\n---------\n\nOur join can be interpreted like this:\n\nmy_table_1 a FULL OUTER JOIN my_table_2 b\n\nNote that the join produces a rowset that has two columns: MY_DATA, which represents my_table_1.my_data, and MY_DATA_1, which represents my_table_2.my_data (the _1 is added at the end automatically by Oracle to prevent column ambiguity).\n\nWe return all rows from my_table_1 and all rows from my_table_2, but connecting the rows where my_table_1.my_data = my_table_2.my_data, which never happens in our data set.\n\nSo our result looks like this:\n \n-------------------\n|MY_DATA|MY_DATA_1|\n-------------------\n|  NULL |    3    |\n|  NULL |    4    | \n|   1   |   NULL  | \n|   2   |   NULL  | \n-------------------\n\n\nSince four rows are returned, COUNT(*) = 4, which is our result.\n","id":300},

// ask a question about USING only returning 1 column
{"explanation":"A JOIN ... USING(column_names) clause is an INNER JOIN on the supplied columns. The USING clause will be transformed to an ON clause that checks for equality between the named columns in the two tables.\n\nAfter the INSERT statements, my_table_1 has the following data in it:\n\n---------\n|MY_DATA|\n---------\n|   1   |\n|   2   |\n---------\n\nand my_table_2 has the following data in it:\n\n---------\n|MY_DATA|\n---------\n|   1   |\n|   4   |\n---------\n\nOur join is:\n\nmy_table_1 a JOIN my_table_2 b USING(my_data)\n\nWhich is equivalent to:\n\nmy_table_1 a INNER JOIN my_table_2 b ON a.my_data = b.my_data\n\nNote that unlike other joins except for NATURAL joins, the USING clause returns only one column (MY_DATA), instead of two columns (MY_DATA, MY_DATA_1)\n\nWe return the rows where my_data is the same value in both my_table_1 and my_table_2. Both tables have a row with [1] in it, so this join produces the following result set:\n\nSo our result looks like this:\n \n---------\n|MY_DATA|\n---------\n|   1   |\n---------\n\n\nSince one row is returned, COUNT(*) = 1, which is our result.\n","id":301},
{"explanation":"Execution fails because you cannot use table aliases in a USING clause. Oracle throws a \"only simple column names allowed here\" error.","id":302},
{"explanation":"Execution fails because my_table_2 does not contain a column named 'my_data'. The columns listed in the USING clause must be present in both of the two tables being joined. \n\n","id":303},
{"explanation":"After the INSERT statements, my_table_1 has the following data in it:\n\n---------\n|MY_DATA|\n---------\n|   1   |\n|   2   |\n---------\n\nand my_table_2 has the following data in it:\n\n---------\n|MY_DATA|\n---------\n|   1   |\n|   4   |\n---------\n\nOur join is:\n\nmy_table_1 a JOIN my_table_2 b ON a.my_data < b.my_data\n\nNote that the join produces a rowset that has two columns: MY_DATA, which represents my_table_1.my_data, and MY_DATA_1, which represents my_table_2.my_data (the _1 is added at the end automatically by Oracle to prevent column ambiguity).\n\nThis join returns row combinations from my_table_1 and my_table_2 such that my_table_1.my_data < my_table_2.my_data. Both [1] and [2] in my_table_1.my_data are less than [4] in my_table_2, so the following data is returned:\n\n-------------------\n|MY_DATA|MY_DATA_1|\n-------------------\n|   1   |    4    | \n|   2   |    4    | \n-------------------\n\n\nSince two rows are returned, COUNT(*) = 2, which is our result.\n\n","id":304},
{"explanation":"A FULL OUTER JOIN connects rows as long as they exist in at least one of the joined tables.\n\nAfter the INSERT statements, my_table_1 has the following data in it:\n\n---------\n|MY_DATA|\n---------\n|   1   |\n|   2   |\n---------\n\nand my_table_2 has the following data in it:\n\n---------\n|MY_DATA|\n---------\n|   1   |\n|   4   |\n---------\n\nOur join is:\n\nmy_table_1 a FULL OUTER JOIN my_table_2 b ON a.my_data < b.my_data;\n\nNote that the join produces a rowset that has two columns: MY_DATA, which represents my_table_1.my_data, and MY_DATA_1, which represents my_table_2.my_data (the _1 is added at the end automatically by Oracle to prevent column ambiguity).\n\nThis join returns row combinations from my_table_1 and my_table_2 such that my_table_1.my_data < my_table_2.my_data. Because this is a FULL OUTER JOIN, if any rows in either table do not match to my_table_1.my_data < my_table_2.my_data for any combination of rows, they are STILL returned but with the other table defaulting to NULL.\n\n\n-------------------\n|MY_DATA|MY_DATA_1|\n-------------------\n|   1   |    4    | \n|   2   |    4    | \n|  NULL |    1    | \n-------------------\n\n\nSince two rows are returned, COUNT(*) = 3, which is our result.\n\n","id":305},


