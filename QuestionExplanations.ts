var QuestionExplanations =
[

{"explanation":"DML statements manipulate data. Because SELECT is used to retrieve data sets, it is considered DML.","id":"0"},
{"explanation":"DML statements manipulate data. Because INSERT is used to add data to a table, it is considered DML.","id":"1"},
{"explanation":"DML statements manipulate data. Because UPDATE is used to modify data in a table, it is considered DML.","id":"2"},
{"explanation":"DML statements manipulate data. Because DELETE is used to remove data in a table, it is considered DML.","id":"3"},
{"explanation":"DML statements manipulate data. Because MERGE is used to add, remove or update data in a table, it is considered DML.","id":"4"},
{"explanation":"DDL statements are used to define database structure. Because CREATE is used to instantiate new database objects, it is considered a DDL statement.","id":"5"},
{"explanation":"DDL statements are used to define database structure. Because ALTER is used to modify database object structures it is considered a DDL statement.","id":"6"},
{"explanation":"DDL statements are used to define database structure. Because DROP is used to delete database objects it is considered a DDL statement.","id":"7"},
{"explanation":"DDL statements are used to define database structure. Because RENAME is used to give a database object a new name, it is considered a DDL statement.","id":"8"},
{"explanation":"DDL statements are used to define database structure. Even though TRUNCATE is used to remove data from a table, it does so by changing table parameters such as 'NEXT' rather than directly manipulating the data. Therefore it is considered a DDL statement.","id":"9"},
{"explanation":"DDL statements are used to define database structure. Because GRANT is used to provide privileges to user objects, it is considered a DDL statement.","id":"10"},
{"explanation":"DDL statements are used to define database structure. Because REVOKE is used to remove privileges frpm user objects, it is considered a DDL statement.","id":"11"},
{"explanation":"DDL statements are used to define database structure. Because FLASHBACK is used to restore a table to a previous version, it is considered a DDL statement.","id":"12"},
{"explanation":"DDL statements are used to define database structure. Because PURGE is used to remove objects from the database recycle bin, it is considered a DDL statement.","id":"13"},
{"explanation":"DDL statements are used to define database structure. Because COMMENT is used to tag meta information to database objects, it is considered a DDL statement.","id":"14"},
{"explanation":"TCL statements are used to control database session transactions. Because COMMIT saves the state of the current session to the database, it is considered a TCL statement.","id":"15"},
{"explanation":"TCL statements are used to control database session transactions. Because ROLLBACK reverts the current state of a session, it is considered a TCL statement.","id":"16"},
{"explanation":"USER objects are nonschema so they cannot be owned by a USER, not even itself. PRIVATE SYNONYMs are schema objects so they can be owned by a USER.","id":"49"},
{"explanation":"INDEXes and CONSTRAINTs are in different namespaces. The namespaces for schema objects are different among schemas. USER objects are nonschema so they must be unique across all schemas in a database.","id":"56"},
{"explanation":"One NOT NULL constraint is made on my_id and one PRIMARY KEY constraint is made on my_pk.","id":"58"},
{"explanation":"A column with a NUMBER datatype is defined as NUMBER(precision, scale). Precision is the total number of digits, while scale is the number digits to the right of the decimal that we round to. When precision is defined, but scale is not, scale defaults to 0. In this example we have a precision of 2 and a scale of 0. The precision of 2 reduces 5.67 to 5.6, and the scale of 0 rounds 5.6 up so that there are 0 places after the decimal, equaling 6.","id":"60"},
{"explanation":"With no precision or scale defined in the NUMBER datatype, numeric values are stored without modification","id":"61"},
{"explanation":"A column with a NUMBER datatype is defined as NUMBER(precision, scale). Precision is the total number of digits, while scale is the number digits to the right of the decimal that we round to. In this example we have a precision of 5 and a scale of 2. The precision of 5 retains 5.6789 as-is, but the scale rounds it to two digits after the decimal, equaling 5.68.","id":"62"},
{"explanation":"A column with a NUMBER datatype is defined as NUMBER(precision, scale). Precision is the total number of digits, while scale is the number digits to the right of the decimal that we round to. In this example we have a precision of 4 and a scale of 1. The precision of 4 retains 5.67 as-is, but the scale rounds it to 1 digit after the decimal, equaling 5.7.","id":"63"},
{"explanation":"DATE contains the datetime fields YEAR, MONTH, DAY, HOUR, MINUTE and SECOND.","id":"64"},
{"explanation":"There is no CREATE CONSTRAINT statement in Oracle.","id":"67"},
{"explanation":"CHECK constraints must evaluate to true or unknown to not throw an error. Because the expression \"NULL IN (1,2)\" evaluates to an unknown value, NULL would not throw a constraint error. 'my_value' would throw an invalid number exception. ","id":"76"},
{"explanation":"CHECK constraints must evaluate to true or unknown to not throw an error. Because the expression \"NULL BETWEEN 1 AND 2\" evaluates to an unknown value, NULL would not throw a constraint error. BETWEEN is an inclusive so both 1 and 2 are valid inputs.","id":"77"},
{"explanation":"Child-key columns in a foreign key constraint can always be dropped, but Parent-key columns must use CASCADE CONSTRAINTS.","id":"79"},
{"explanation":"After my_status is dropped, my_fk is dropped in addition to the NOT NULL and UNIQUE constraints on my_status. This leaves only the PRIMARY KEY and CHECK constraints on my_id.","id":"80"},
{"explanation":"An error is thrown because columns used in multi-column constraints cannot be dropped without a CASCADE CONSTRAINTS clause.","id":"81"},
{"explanation":"The CASCADE CONSTRAINTS clause in the ALTER TABLE... DROP COLUMN statement caused both my_pk_2 and my_fk to be dropped because they referenced the my_status column.","id":"82"},
{"explanation":"A PRIMARY KEY constraint creates an INDEX object of the same name, so when line 3 executes an INDEX called \"my_obj\" will already exist.","id":"96"},
{"explanation":"BLOBs cannot be used as PRIMARY KEYs, so line 2 is an error. VARCHAR2 requires a length parameter, so line 4 fails.","id":"101"},
{"explanation":"LOB objects cannot be the subject of a UNIQUE constraint.","id":"102"},
{"explanation":"PRIMARY KEY constraints are equivalent to a UNIQUE INDEX and a NOT NULL constraint. NOT NULL constraints cannot be created out-of-line.","id":"103"},
{"explanation":"BLOBs cannot be used as PRIMARY KEYs, so line 2 is an error. VARCHAR2 requires a length parameter, so line 4 fails.","id":"104"},
{"explanation":"You cannot TRUNCATE a table which is the parent in a referential constraint. Even if the TRUNCATE fails, it still commits.","id":"107"},
{"explanation":"Line 5 tries to insert NULL into the my_id column, even though it is under a PRIMARY KEY constraint. ","id":"111"},
{"explanation":"Even though my_id is a NUMBER field, Oracle can implicitly convert '1' to 1, thus being a valid clause.","id":"112"},
{"explanation":"The \"VALUES\" keyword is missing.","id":"115"},




];